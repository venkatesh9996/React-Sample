import $ = require("jquery");
import _ = require("underscore");
import q = require("q");
import ko = require("knockout");
import ViewUtilities = require("utilities/view");
import webStrings = require("strings!web");
import companyStrings = require("strings!company");
import asyncUtilities = require("utilities/async");
import securityClient = require("security/client!");
import shellViewModel = require("views/shell!");
import chartDataModel = require("models/chartBuilder/data");
import dataSeriesModel = require("models/dataSeries/request");
import common = require("common");
import modelUtilities = require("utilities/model");
import exportUtil = require("utilities/export");
import localizationUtility = require("utilities/localization");
import dateUtilities = require("utilities/date");
import stringUtilities = require("utilities/string");
import moment = require("moment");
import app = require("durandal/app");
import zone = require("bindings/zone");
import gUtils = require("views/chartbuilder/utils/genericUtil");
import intraday = require("views/chartbuilder/utils/intraday");
import menuModel = require("models/menu/default");
import host = require("host");
import periodicUtil = require("./common/chart/periodicUtil");
import formationUtil = require("./utils/formation");
import OfficeChartingViewModel = require("./officeExportChart/index");
import CBModels = require("./models/models");
import ResetChartBuilder = require("./helpers/resetChartBuilder");
import dialog = require("plugins/dialog");
import SaveAndLoadDialogViewModel = require("./dialogs/saveAndLoadDialog/index");
import anntUtil = require("./settingsSidebar/annotations/annotationUtil");
import yAxisUtil = require("./utils/yAxis");
import imposition = require("./helpers/imposition");
import uriUtilities = require("utilities/uri");
import eventConstants = require("events/constants");
import crossSiteFiltersStore = require("storage/store!web/crossSiteFilters/persistent");
import pinnAnnt = require("./utils/pinnableAnnotation");
import MIChartBuilderCommon = require("models/chartBuilder/chartBuilderCommon");
import GridInterfaces = require("utilities/grid.interfaces");
import chartBuilderDataStorageModel = require("models/chartBuilder/storage");
import ajaxUtilities = require("utilities/ajax");
import perspective = require("models/advancedSearch/perspective/perspective");
import "text!./index.html";
import "less!./index";
import replaceEntityUtil = require("views/chartbuilder/utils/replaceEntityUtil");
import stockChartUtil = require("views/chartbuilder/utils/stockUtil");
import SaveTemplateViewModel = require("./dialogs/saveTemplate/index");
import LoadTemplateViewModel = require("./dialogs/loadTemplate/index");
import loadTemplateUtil = require("views/chartbuilder/utils/loadTemplateUtil");
import migrateCIQChartsUtil = require("views/chartbuilder/utils/migrateCIQChartsUtil");
import ApplyTemplateConfirmationDialogViewModel = require("./dialogs/applyTemplateConfirmation/index");

var crossSiteFiltersObservables = crossSiteFiltersStore.observables();
var crossSiteFilterCurrencyObservable: any = crossSiteFiltersObservables.item("crossSiteFilterCurrency");
var excelDecimalNumberFormats: any = {
    "default": '#,##0.00',
    "actual": '#,##0.00',
    "thousands": '#,##0.00,\\k',
    "millions": '#,##0.00,,\\M',
    "billions": '#,##0.00,,,\\B',
    "trillions": '#,##0.00,,,,\\T'
};

var chartCustomizationAction: any = {
    updateTitle: "updateTitle",
    updateSubTitle: "updateSubTitle"
};

var defaultKeyDevOpts: any = {
    subsideries: false,
    investments: false
};
//MACD, RSI should be calculted on day close price & SettlementPrice metric only
var dayClosePrice: any = {
    dataSeriesTemplates: "DataSeries_MarketData",
    defaultMagnitude: "($)",
    displayMask: "#,##0.00",
    isChartableField: undefined,
    isPeriodic: false,
    isPreserved: undefined,
    isStaticMetric: false,
    key: 290930,
    keyFieldDisplayInfo: 290930,
    keyItem: "1062",
    keyProductQueryItemDisplay: null,
    localizedAlias: "SP_PRICE_CLOSE",
    localizedCaption: "Share Price",
    localizedFieldKeyPath: "290909|290930",
    localizedFieldPath: "[Pricing Information] / [Share Price]",
    magnitude: "(Reported)",
    maskProductQueryVersion: 480,
    secondaryKeyListsDisplayType: null,
    secondaryKeys: [],
    subcategoryCaption: "Pricing Information",
    subcategoryCategoryCaption: "Equity Market Data"
};
let settlementPrice: any = {
    dataSeriesTemplates: "DataSeries_MarketData",
    defaultMagnitude: "($)",
    displayMask: "",
    isChartableField: undefined,
    isPeriodic: false,
    isPreserved: undefined,
    isStaticMetric: false,
    key: 319623,
    keyFieldDisplayInfo: 319623,
    keyItem: "45428",
    keyProductQueryItemDisplay: null,
    localizedAlias: "",
    localizedCaption: "Settlement Price",
    localizedFieldKeyPath: "269213|319247|319623",
    localizedFieldPath: "[Market Data] / [Commodities] / [Settlement Price]",
    magnitude: "",
    maskProductQueryVersion: 132,
    secondaryKeyListsDisplayType: null,
    secondaryKeys: [],
    subcategoryCaption: "Market Data",
    subcategoryCategoryCaption: "Commodities"
};

//Logs the messages to office log files
function logOfficeMessages(message: string) {
    if (common.isOffice) {
        host.providers.officeModel.logMessage('Office Charting:- ' + message);
    }
}

logOfficeMessages("All Js files loaded");

function getlocalizedDateStringInvariant(value: any, culture: string) {
    var localizedDate = dateUtilities.convertStringToDate(moment.utc(value).format());
    return localizationUtility.format(localizedDate, "SHORT", (culture ? culture : securityClient.userProfile().Culture));
}

var self: any = {};

class ChartBuilderViewModel {
    public seriesIdCounter: number;
    public paneCounter: number;
    public view: any;
    public chartBuilderInstance: CBModels.ChartBuilder;
    public inProgressSeries: any;
    public isStockChartModeEnabled: boolean;
    public isPlattsEnabled: boolean;
    public stockChartEntityId: string | null;
    public entitySelectedValue: KnockoutObservableArray<any>;
    public previousEntities: KnockoutObservableArray<any>;
    public validatingNokeyDevs: KnockoutObservableArray<any>;
    public metricsSelectedValues: KnockoutObservableArray<any>;
    public actualData: KnockoutObservableArray<any>;
    public reportBuilderSavedData: any;
    public yAxes: KnockoutObservableArray<any>;
    public selectedKeyDevTypeIds: KnockoutObservableArray<string>;
    public selectedKeyDevSeriesIds: KnockoutObservableArray<string>;
    public keyDevs: KnockoutObservable<CBModels.SeriesKeyDevDict>;
    public customKeyDevs: KnockoutObservable<any>;
    public removedKeyDevs: KnockoutObservable<any>;
    public globalPos: CBModels.GlobalPosI;
    public currentColorIndex: number;
    public preventReload: KnockoutObservable<boolean>;
    public chartControl: KnockoutObservable<Highstock.ChartObject | any>;
    public chartExportPromise: KnockoutObservable<any>;
    public chartExportSchema: KnockoutObservable<any>;
    public paneImageSchema: KnockoutObservable<any>;
    public summaryExportSchema: KnockoutObservable<any>;
    public preservedMetrics: KnockoutObservableArray<any>;
    public preservedEntities: KnockoutObservableArray<any>;
    public usage: CBModels.UsageI;
    public preservedSavedChartName: KnockoutObservable<any>;
    public keyPage: number;
    public tools: any;
    public viewContext: ViewUtilities;
    public zoneContext: zone;
    public isStockChart: KnockoutObservable<boolean>;
    public hiddenSeries: KnockoutObservableArray<any>;
    public chartExportType: KnockoutObservable<any>;
    public chartExportImageWidth: number = 1200;
    public selectedCurrFromDD: KnockoutObservable<any>;
    public currencyFromSaveChart: KnockoutObservable<any>;
    public refreshChartSummary: KnockoutObservable<boolean>;
    public innerWidth: KnockoutObservable<any>;
    public isSubTitleAtBottomRight: KnockoutObservable<boolean>;
    public dateRange: CBModels.DateRangeI;
    public isOffice: KnockoutObservable<boolean>;
    public currentActivePane: KnockoutObservable<any>;
    public compComplete: KnockoutObservable<boolean>;
    public isOfficeInsertMode: KnockoutObservable<boolean>;
    public isOfficeUpdateMode: KnockoutObservable<boolean>;
    public isOfficeRefreshMode: KnockoutObservable<boolean>;
    public isChartDataReadyToInsert: KnockoutObservable<boolean>;
    public isGetChartSVGCalled: KnockoutObservable<boolean>;
    public isAnnotationsDataReadyToInsert: KnockoutObservable<boolean>;
    public openAddSeries: KnockoutObservable<boolean>;
    public panesCollection: KnockoutObservableArray<CBModels.Pane>;
    public firstPane: KnockoutComputed<CBModels.Pane>;
    public firstPaneSeries: KnockoutComputed<KnockoutObservableArray<CBModels.Series>>;
    public firstPaneSeriesArr: KnockoutComputed<Array<CBModels.Series>>;
    public allPanesSeriesArr: KnockoutObservableArray<CBModels.Series>;
    public officeExportChart: any;
    public previousSelectedCurrency: any;
    public previousSelectedTemplate: any;
    public deletedListInfo: string[];
    public resetSeriesCollection: KnockoutObservableArray<CBModels.Series>;

    public addSeries: (newSeriesCollection: any) => void;
    public adjustTitleOrSubTitleorLegendPositions: (updateObject: any, action: any, isRedraw: boolean, updateObjectSettings: any, isGlobalUpdate: boolean, paneId: number) => void;
    public updateSeriesName: (seriesid: any, seriesName: any) => void;
    public updateSeriesColor: (seriesid: any, seriesName: any) => void;
    public updateLineSeriesWidthOrStyle: (seriesId: any, lineWidth: number, lineStyle: string, updateWidth: boolean) => void;
    public updateSeriesFromTimeFrame: (datesChangedByButton: any, currency: any, shouldAdjustStartDate: any, editableSeries?: Array<any>, isFromAdjustStartDate?: boolean) => void;
    public removeSeries: (targetSeriesCollection: any, shouldRemoveEntity?: boolean, shouldRemoveMetrics?: boolean) => void;
    public getJSDateFromYYYYMMDD: (input: any) => Date;
    public updateHighchartLabels: () => void;
    public offlineExport: () => void;
    public excelExport: () => void;
    public pdfExport: () => void;
    public htmlExport: () => void;
    public wordExport: () => void;
    public saveChartbuilderInstance: () => void;
    public openSavedChartbuilderInstance: () => void;
    public getDefaultSettingsForSideBar: () => CBModels.SidebarSettings;
    public getChartBuilderInstanceDefaultState: () => CBModels.ChartBuilder;
    public adjustStartDate: () => void;
    public addSeriesFromTopBarEntity: (entityCollection: any) => void;
    public addSeriesFromTopBarMetric: (metricsCollection: any) => void;
    public removeTargetSeriesCollectionByElement: (collection: any, context: any) => void;
    public handleNoDataMessage: (newSeries: any) => void;
    public removeStudiesForIntradaySeries: () => void;
    public removeHighchartSeries: (targetSeriesIds: any, paneId: number) => void;
    public removeHighChart: (chartIndex: number) => void;
    public removePane: (paneId: number) => void;
    public generateDummyData: (startDate: any, endDate: any) => Array<any>;
    public updateChartTitle: (titleObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
    public updateChartSubTitle: (subTitleObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
    public updateChartXAxisLabel: (xAxisLabelObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
    public updateXAxisFont: (xAxisObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
    public updateChartLegendName: (legendObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
    public updateYAxisGridLines: (isGridLines: boolean) => void;
    public generateDummySeries: () => void;
    public getDefaultyAxis: () => void;
    public changeSeriesName: (seriesid: any, seriesName: any) => void;
    public resizeSidebar: () => any;
    public _resizeChartWindow: () => void;
    public _resizeHandler: any;
    public getNextAvailableColor: (seriesCollection: any[]) => string;
    public disableAutoOpen: boolean;
    public redrawChart: () => void;
    public getFormattedDateForSingleDigitMonth: (value: string) => string;
    public selectedColorPaletteId: KnockoutObservable<number>;
    public dataloadComplete: any;
    public isReportBuilder: boolean;
    public showShareDialog: () => void;
    public selectedSavedChart: any;
    public hasTotalReturn: KnockoutObservable<boolean>;
    public footnotes: any[] = [{ footnotetext: companyStrings.totalReturnNoDataFootnote(), mode: 0 }];
    public footnoteExportSchema: KnockoutObservable<any>;
    public showShareDialogNext: boolean;
    public keyOnlineSharedItem: any;
    public sharedItemAccessLevel: any;
    public saveChartButtonText: KnockoutObservable<any>;
    public onlineSharedItemShareable: boolean;
    public showVolumeMessage: KnockoutObservable<boolean>;
    public isLoadChart: boolean;
    public savedTemplates: KnockoutObservableArray<any>;
    public selectedTemplate: KnockoutObservable<any>;
    public saveChartTemplate: () => void;
    public sidebarSelectedPaneId: KnockoutObservable<number>;
    public sidebarSelectedPaneSeries: KnockoutObservable<any>;
    public sidebarSelectedPaneSeriesArr: KnockoutObservable<any>;
    public sidebarSelectedPaneYAxes: KnockoutObservable<any>;

    public selectedAnnotationPane: KnockoutObservable<any>;
    public selectedAnnotationPaneSeries: KnockoutObservable<any>;
    public selectedAnnotationPaneObj: KnockoutObservable<any>;
    public selectedAnnotationChartObj: KnockoutObservable<any>;


    public globalRelativity: KnockoutObservable<CBModels.Relativity>;

    public saveModificationHandler: () => void;
    public isGSUser: boolean;



    constructor() {
        self = this;
        logOfficeMessages("constructor start");
        this.seriesIdCounter = 0;
        this.paneCounter = 1;
        self.resetSeriesCollection = {} as KnockoutObservableArray<CBModels.Series>;
        this.isStockChartModeEnabled = false;
        this.isPlattsEnabled = false;
        this.stockChartEntityId = uriUtilities.getParamValue("id");
        this.disableAutoOpen = false;
        this.dataloadComplete = q.defer();
        if (this.stockChartEntityId) {
            this.isStockChartModeEnabled = true;
        }
        this.deletedListInfo = [];
        this.globalPos = { currTimePos: null, prevTimePos: null };

        //TODO: Eliminate these and see what errors we get.
        this.chartBuilderInstance = {} as CBModels.ChartBuilder;
        this.entitySelectedValue = {} as KnockoutObservableArray<any>;
        this.previousEntities = {} as KnockoutObservableArray<any>;
        this.validatingNokeyDevs = {} as KnockoutObservableArray<any>;
        this.metricsSelectedValues = {} as KnockoutObservableArray<any>;
        this.actualData = {} as KnockoutObservableArray<any>;
        this.yAxes = {} as KnockoutObservableArray<CBModels.Yaxis>;
        this.preventReload = {} as KnockoutObservable<boolean>;
        this.selectedKeyDevTypeIds = {} as KnockoutObservableArray<string>;
        this.selectedKeyDevSeriesIds = {} as KnockoutObservableArray<string>;
        this.keyDevs = {} as KnockoutObservable<CBModels.SeriesKeyDevDict>;
        this.customKeyDevs = {} as KnockoutObservable<any>;
        this.removedKeyDevs = {} as KnockoutObservable<any>;
        this.chartControl = {} as KnockoutObservable<Highstock.ChartObject | null>;
        this.chartExportPromise = {} as KnockoutObservable<any>;
        this.chartExportSchema = {} as KnockoutObservable<any>;
        this.paneImageSchema = {} as KnockoutObservable<any>;
        this.summaryExportSchema = {} as KnockoutObservable<any>;
        this.preservedMetrics = {} as KnockoutObservableArray<any>;
        this.preservedEntities = {} as KnockoutObservableArray<any>;
        this.usage = {} as CBModels.UsageI;
        this.preservedSavedChartName = {} as KnockoutObservable<any>;
        this.keyPage = 364852;
        this.viewContext = {} as ViewUtilities;
        this.zoneContext = {} as zone;
        this.isStockChart = {} as KnockoutObservable<boolean>;
        this.hiddenSeries = {} as KnockoutObservableArray<any>;
        this.chartExportType = {} as KnockoutObservable<any>;
        this.selectedCurrFromDD = {} as KnockoutObservable<any>;
        this.currencyFromSaveChart = {} as KnockoutObservable<any>;
        this.refreshChartSummary = {} as KnockoutObservable<boolean>;
        this.innerWidth = {} as KnockoutObservable<any>;
        this.isSubTitleAtBottomRight = {} as KnockoutObservable<boolean>;
        this.dateRange = {} as CBModels.DateRangeI;
        this.isOffice = {} as KnockoutObservable<boolean>;
        this.currentActivePane = {} as KnockoutObservable<any>;
        this.compComplete = {} as KnockoutObservable<boolean>;
        this.isOfficeInsertMode = {} as KnockoutObservable<boolean>;
        this.isOfficeUpdateMode = {} as KnockoutObservable<boolean>;
        this.isOfficeRefreshMode = {} as KnockoutObservable<boolean>;
        this.isChartDataReadyToInsert = {} as KnockoutObservable<boolean>;
        this.isAnnotationsDataReadyToInsert = {} as KnockoutObservable<boolean>;
        this.selectedColorPaletteId = {} as KnockoutObservable<number>;
        this.openAddSeries = {} as KnockoutObservable<boolean>;
        this.panesCollection = {} as KnockoutObservableArray<CBModels.Pane>;
        this.firstPane = {} as KnockoutComputed<CBModels.Pane>;
        this.firstPaneSeries = {} as KnockoutComputed<KnockoutObservableArray<CBModels.Series>>;
        this.firstPaneSeriesArr = {} as KnockoutComputed<Array<CBModels.Series>>;
        this.allPanesSeriesArr = {} as KnockoutObservableArray<CBModels.Series>;
        this.addSeries = {} as (newSeriesCollection: any) => void;
        this.adjustTitleOrSubTitleorLegendPositions = {} as (updateObject: any, action: any, isRedraw: boolean, updateObjectSettings: any, isGlobalUpdate: boolean, paneId: number) => void;
        this.updateSeriesName = {} as (seriesid: any, seriesName: any) => void;
        this.updateSeriesColor = {} as (seriesid: any, seriesColor: any) => void;
        this.updateLineSeriesWidthOrStyle = {} as (seriesId: any, lineWidth: number, lineStyle: string, updateWidth: boolean) => void;
        this.showVolumeMessage = {} as KnockoutObservable<boolean>;
        this.updateSeriesFromTimeFrame = {} as (datesChangedByButton: any, currency: any, shouldAdjustStartDate: any, editableSeries?: Array<any>, isFromAdjustStartDate?: boolean) => void;
        this.removeSeries = {} as (targetSeriesCollection: any, shouldRemoveEntity?: boolean, shouldRemoveMetrics?: boolean) => void;
        this.getJSDateFromYYYYMMDD = {} as (input: any) => Date;
        this.updateHighchartLabels = {} as () => void;
        this.offlineExport = {} as () => void;
        this.excelExport = {} as () => void;
        this.pdfExport = {} as () => void;
        this.htmlExport = {} as () => void;
        this.showShareDialog = {} as () => void;
        this.wordExport = {} as () => void;
        this.saveChartbuilderInstance = {} as () => void;
        this.openSavedChartbuilderInstance = {} as () => void;
        this.getDefaultSettingsForSideBar = {} as () => CBModels.SidebarSettings;
        this.getChartBuilderInstanceDefaultState = {} as () => CBModels.ChartBuilder;
        this.adjustStartDate = {} as (updateTimeFrame?: boolean) => void;
        this.addSeriesFromTopBarEntity = {} as (entityCollection: any) => void;
        this.addSeriesFromTopBarMetric = {} as (metricsCollection: any) => void;
        this.removeTargetSeriesCollectionByElement = {} as (collection: any, context: any) => void;
        this.handleNoDataMessage = {} as (newSeries: any) => void;
        this.removeStudiesForIntradaySeries = {} as () => void;
        this.removeHighchartSeries = {} as (targetSeriesIds: any, paneId: number) => void;
        this.removeHighChart = {} as (chartIndex: number) => void;
        this.removePane = {} as (paneId: number) => void;
        this.generateDummyData = {} as (startDate: any, endDate: any) => Array<any>;
        this.updateChartTitle = {} as (titleObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: any) => void;
        this.updateChartSubTitle = {} as (subTitleObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: any) => void;
        this.updateChartXAxisLabel = {} as (xAxisLabelObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
        this.updateXAxisFont = {} as (xAxisObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
        this.updateChartLegendName = {} as (legendObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number) => void;
        this.updateYAxisGridLines = {} as (isGridLines: boolean) => void;
        this.generateDummySeries = {} as () => void;
        this.getDefaultyAxis = {} as () => void;
        this.changeSeriesName = {} as (seriesid: any, seriesName: any) => void;
        this.resizeSidebar = {} as () => any;
        this._resizeChartWindow = {} as () => void;
        this.getNextAvailableColor = {} as (seriesCollection: any[]) => string;
        this.redrawChart = {} as () => void;
        this.getFormattedDateForSingleDigitMonth = {} as (value: string) => string;
        this.showShareDialogNext = false;
        this.sharedItemAccessLevel = "";
        this.saveChartButtonText = {} as KnockoutObservable<any>;
        this.onlineSharedItemShareable = true;
        this.saveModificationHandler = {} as () => void;
        this.isLoadChart = false;
        this.isGSUser = false;
        this.savedTemplates = {} as KnockoutObservableArray<any>;
        this.selectedTemplate = {} as KnockoutObservable<any>;
        this.saveChartTemplate = {} as () => void;
        this.globalRelativity = {} as KnockoutObservable<CBModels.Relativity>;
        this.selectedSavedChart = {} as () => any;
        logOfficeMessages("constructor end");
        this.sidebarSelectedPaneId = {} as KnockoutObservable<number>;
        this.sidebarSelectedPaneSeries = {} as KnockoutObservable<any>;
        this.sidebarSelectedPaneSeriesArr = {} as KnockoutObservable<any>;
        this.sidebarSelectedPaneYAxes = {} as KnockoutObservableArray<CBModels.Yaxis>;

        this.selectedAnnotationPane = {} as KnockoutObservable<any>;
        this.selectedAnnotationPaneSeries = {} as KnockoutObservable<any>;
        this.selectedAnnotationPaneObj = {} as KnockoutObservable<any>;
        this.selectedAnnotationChartObj = {} as KnockoutObservable<any>;


    }

    public comparePeriodTypes(primarySeries: any, series: any) {
        var primarySeriesPeriods = _.map(primarySeries.userOptions.data, (d: any) => d.meta.periodDisplay);
        var seriesPeriods = _.map(series.userOptions.data, (d: any) => d.meta.periodDisplay);

        var difference = _.difference(primarySeriesPeriods, seriesPeriods);

        return difference.length === 0;
    }

    public getChartSVG(currChart: any) {
        if (currChart) {
            self.chartControl(currChart);
        }
        let pinnedAnotations = $(self.view).find('.chart-area-container').find('.pinn-annotation');
        let chart: any;
        let exportType = self.chartExportType();
        switch (exportType) {
            case exportUtil.enums.format.pdf: {
                chart = gUtils.calculateYForTitleSubTitleLegend(currChart, self.chartExportType() === exportUtil.enums.format.pdf);
                break;
            }
            case exportUtil.enums.format.word: {
                chart = gUtils.calculateYForTitleSubTitleLegend(currChart, false, exportUtil.enums.format.word);
                break;
            }
            default:
                chart = gUtils.calculateYForTitleSubTitleLegend(currChart, false);
                break;
        }
        var expChart = (_.get(pinnedAnotations, 'length', 0) > 0 && exportType !== exportUtil.enums.format.pdf && exportType !== exportUtil.enums.format.word && chart.chartDetails.chart.height > 450) ? pinnAnnt.exportPinnAnnt(chart) : undefined;
        // added new condition here due to updating CHild Pane width accoarding to Parent pane Plotted Image width.
        var charts: any = _.compact(_.get(window, 'Highcharts.charts', []));
        var isChildseries = _.filter(charts, function (siri: any) {
            return siri.userOptions.chart.isChildChart;
        });
        // allowing only if child panes are plotted....
        if (isChildseries.length > 0) {
            var parentPaneWidth = charts[0];
            if (currChart.userOptions.chart.isChildChart) {
                if (exportType === exportUtil.enums.format.word || exportType === exportUtil.enums.format.excel || exportType === exportUtil.enums.format.pdf || exportType === exportUtil.enums.format.image) {// if file type is word we are calculating plotted area width
                    let plottedAxiswidth = parentPaneWidth.chartWidth - parentPaneWidth.plotWidth;
                    let defaultChildpanewidth = chart.chartDetails.chart.width + currChart.plotBox.x + 15;
                    chart.chartDetails.chart.width = defaultChildpanewidth - plottedAxiswidth;
                }
                else {
                    chart.chartDetails.chart.width = parentPaneWidth.plotWidth + currChart.plotBox.x + 15;
                }
            }
        }
        //   # EOF
        if (expChart) {
            return self.chartControl().getSVG(expChart);
        } else {
            return self.chartControl().getSVG(chart.chartDetails);
        }
    }
    public getMultiPaneSVGs(isfromExport: boolean = false) {
        let chartPanes = self.chartBuilderInstance.panes();
        let paneArrays: any = [];
        let innerchildArray: any = [];

        let parentPanes = _.filter(chartPanes, function (panes: any) {
            return !panes.isChildPane;
        });
        _.each(parentPanes, (arr: any) => {
            if (arr.childPaneIds.length > 0 && !arr.isChildPane) {
                innerchildArray = [];
                innerchildArray.push(gUtils.findHighchartById(self.view, _.get(arr, 'chartId')));
                _.filter(arr.childPaneIds, (childArry: any) => {
                    var childPanes = _.find(chartPanes, function (panes: any) {
                        return panes.id === childArry;
                    });
                    innerchildArray.push(gUtils.findHighchartById(self.view, _.get(childPanes, 'chartId')));
                });
                paneArrays.push(innerchildArray);
            } else {
                paneArrays.push([gUtils.findHighchartById(self.view, _.get(arr, 'chartId'))]);
            }
        });
        if (isfromExport) { return paneArrays; }
        // _.each(paneArrays, (chart: any) => {
        let result = self.getChartmultiSVGs(paneArrays);
        return result;
    }
    public getChartmultiSVGs(charts: any) {
        var svgArr: Array<any> = [];
        var svgArrGroup: Array<any> = [];
        var top = 0, width = 0;
        _.each(charts, (paneChart: any) => {
            paneChart = _.compact(paneChart);
            if (paneChart.length > 1) {
                svgArr = []; top = 0, width = 0;
                _.each(paneChart, (chart: any) => {
                    let svg = self.getChartSVG(chart);
                    var svgWidth = +svg.match(
                        /^<svg[^>]*width\s*=\s*\"?(\d+)\"?[^>]*>/
                    )[1];
                    var svgHeight = +svg.match(
                        /^<svg[^>]*height\s*=\s*\"?(\d+)\"?[^>]*>/
                    )[1];

                    svg = svg.replace('<svg', '<g transform="translate(0,'
                        + top + ')" ');
                    svg = svg.replace('</svg>', '</g>').replace('&lt;/span&gt;', '</span>').replace(/&gt;/g, ">").replace(/&lt;/g, "<");
                    top += svgHeight;
                    width = Math.max(width, svgWidth);
                    svgArr.push(svg);

                });
            } else {
                // will move to generic function this repeated
                svgArr = []; top = 0, width = 0;
                let svg = self.getChartSVG(paneChart[0]);
                var svgWidth = +svg.match(
                    /^<svg[^>]*width\s*=\s*\"?(\d+)\"?[^>]*>/
                )[1];
                var svgHeight = +svg.match(
                    /^<svg[^>]*height\s*=\s*\"?(\d+)\"?[^>]*>/
                )[1];

                svg = svg.replace('<svg', '<g transform="translate(0,'
                    + top + ')" ');
                svg = svg.replace('</svg>', '</g>').replace('&lt;/span&gt;', '</span>').replace(/&gt;/g, ">").replace(/&lt;/g, "<");
                top += svgHeight;
                width = Math.max(width, svgWidth);
                svgArr.push(svg);
            }
            let svgGp = '<svg  height=" ' + top + '" width="' + width
                + '" version="1.1" xmlns="http://www.w3.org/2000/svg">'
                + svgArr.join('') + '</svg>';
            svgArrGroup.push(svgGp);

        });
        return svgArrGroup;
    }
    public getChartSVGs() {

        var svgArr: Array<any> = [];
        var top = 0, width = 0;
        //  let charts = _.compact(_.get(window, 'Highcharts.charts', []));
        let charts = gUtils.getAllHighCharts(self.view);

        _.each(charts, (chart: any) => {
            let svg = self.getChartSVG(chart);
            var svgWidth = +svg.match(
                /^<svg[^>]*width\s*=\s*\"?(\d+)\"?[^>]*>/
            )[1];
            var svgHeight = +svg.match(
                /^<svg[^>]*height\s*=\s*\"?(\d+)\"?[^>]*>/
            )[1];

            svg = svg.replace('<svg', '<g transform="translate(0,'
                + top + ')" ');
            svg = svg.replace('</svg>', '</g>').replace('&lt;/span&gt;', '</span>').replace(/&gt;/g, ">").replace(/&lt;/g, "<");
            top += svgHeight;
            width = Math.max(width, svgWidth);
            svgArr.push(svg);
        });
        return '<svg  height=" ' + top + '" width="' + width
            + '" version="1.1" xmlns="http://www.w3.org/2000/svg">'
            + svgArr.join('') + '</svg>';

    }
    public exportMultipaneChartSvgs(chartSVG: any) {
        return q.when(self.chartExportPromise()).then(function (generateImage: any) {
            return generateImage(chartSVG).then(function () {
            });
        });
    }

    public doExport(exportType: any, svg: any) {
        // let charts = _.compact(_.get(window, 'Highcharts.charts', []));

        var reportCollection: any = [];
        let chartPanes = self.getMultiPaneSVGs(true);
        if (chartPanes) {
            _.each(chartPanes, (series: any, i: number) => {
                let reportSeriesCollection = self.multipaneExportSchema(series, exportType, i, svg[i]);
                reportCollection.push(_.clone(reportSeriesCollection));

            });
        }
        // Build report builder.
        var builder = exportUtil.getReportBuilder(exportType, _.flattenDeep(reportCollection));
        if (builder) {
            if (self.isReportBuilder) {
                //builder object needed to export, keyPage and usage object needed for logging page usage
                return { builder: builder, keyPage: self.keyPage, usage: self.usage };
            } else {
                //For User Story 1690720: B1 MI Charting - Support platform exported charts in Office Charting (image export property)
                builder.reportbuilder["@excelexportformat"] = "Xlsx";
                var jsonschema = JSON.stringify(builder);
                return exportUtil.postExportRequest(common.config.uris.data.export.v2 + 'Generate/', jsonschema, self.successCallBack, self.errorCallBack);
            }
        }
        else {
            return null;
        }
    }

    public getPeriodicLabel(seriesData: any, point: any) {
        var label = "";
        _.each(seriesData, function (siri: any) {
            _.each(siri.userOptions.data, function (data: any) {
                if (data.x === point.getTime()) {
                    label = data.meta.periodDisplay;
                }
            });
        });
        return gUtils.formatfiscalPeriods(label);
    }
    // added for handling multiple Panes **** creating multiple tabs in Export Excel***8
    public multipaneExportSchema(data: any, exportType: any, indPos: any = 0, svg: any) {
        self.exportMultipaneChartSvgs(svg);
        let charts = gUtils.getAllHighCharts(self.view);
        var exportRows: any = [];

        var emptyRow = exportUtil.getRow(null);
        exportRows.push(emptyRow);
        // self.chartExportSchema().rows.reporttablerow[0].cells.reporttablecell[exportUtil.constants.cell.content] = self.paneImageSchema[indPos];

        if (!self.isReportBuilder) {
            //For office chartbuilder support in platform export excel - sending chart metadata to export excel
            var metadata = self.officeExportChart.platformExportChartMetadata();
            //sorting the data based on the entity while exporting
            if (metadata.chartBuilderData) {
                if (metadata.chartBuilderData.entities.length > 1) {
                    metadata.chartBuilderData.entities = metadata.chartBuilderData.entities.sort((x: any, y: any) => x.sequenceId - y.sequenceId);
                }
                // need to sort only pane[0] series
                if (metadata.chartBuilderData.panes[0].seriesCollection.length > 1) {
                    metadata.chartBuilderData.panes[0].seriesCollection = metadata.chartBuilderData.panes[0].seriesCollection.sort((x: any, y: any) => x.entity.sequenceId - y.entity.sequenceId);
                }
            }
            metadata = JSON.stringify(metadata);
            metadata = "SPGMICharting-" + metadata;
            metadata = metadata.replace(/"/g, "'");
            self.chartExportSchema().rows.reporttablerow[0].cells.reporttablecell[exportUtil.constants.cell.alttext] = metadata;
        }

        if (self.titleExportSchema) {
            exportRows = exportRows.concat(self.titleExportSchema);
            exportRows.push(emptyRow); // add empty Row
        }

        //add filters
        exportRows.push(self.getGridTableSchemaRow(self.getFilterExportSchema()));

        //add chart image
        // exportRows.push(self.getGridTableSchemaRow(self.chartExportSchema()));
        exportRows.push(self.getGridTableSchemaRow(self.chartExportSchema()));
        let emptyRowLength = _.reduce(charts, function (rowCount: number, chart: any) {
            //  let emptyRowCount = chart.options.chart.isChildChart ? 12 : 36;
            //  Updating emptyrow count based on new chartheight 495, child chartheight 186
            let emptyRowCount = chart.options.chart.isChildChart ? 10 : 27;
            return rowCount + emptyRowCount;
        }, 0);

        if (exportType === exportUtil.enums.format.excel) {
            //add few empty lines not to overlap on chart image //37
            if (self.isReportBuilder || self.isReportBuilderPreview) {
                emptyRowLength += 8;
            }
            for (var x = 1; x <= emptyRowLength; x++) {
                emptyRow = exportUtil.getRow(null);
                emptyRow[exportUtil.constants.row.rowType] = exportUtil.enums.rowType.empty;
                exportRows.push(emptyRow);
            }
        }
        var reportCollectionSeries: any = [];  // used together collection of items for export

        // var emptyRow = exportUtil.getRow(null);
        //Summary Header

        let summarySchema = self.summaryExportSchema();
        if (exportType !== exportUtil.enums.format.excel) {
            let dateFormat = { override: "MMM-dd-yyyy" };
            let start = new Date(self.chartBuilderInstance.plottedDateRange().start.substring(0, 4), parseInt(self.chartBuilderInstance.plottedDateRange().start.substring(4, 6)) - 1, self.chartBuilderInstance.plottedDateRange().start.substring(6, 8));
            let end = new Date(self.chartBuilderInstance.plottedDateRange().end.substring(0, 4), parseInt(self.chartBuilderInstance.plottedDateRange().end.substring(4, 6)) - 1, self.chartBuilderInstance.plottedDateRange().end.substring(6, 8));
            let startDate = localizationUtility.format(start, dateFormat, 'en-US');
            let endDate = localizationUtility.format(end, dateFormat, 'en-US');

            emptyRow = exportUtil.getRow(null);
            emptyRow[exportUtil.constants.row.rowType] = exportUtil.enums.rowType.empty;
            exportRows.push(emptyRow);

            exportRows.push(exportUtil.getRow(self.getCell(stringUtilities.format('{0} | {1} TO {2}', 'Chart Summary', startDate, endDate), true, true, '8421504', '16777215', 'tableCaption')));

            //This code is require to revisit when we change summary grid, because currently treegrid control doesn't support to set column width as export schema width.
            //Bug#1833433
            let summaryCells = _.get(summarySchema, '[0].rows.reporttablerow[0].cells.reporttablecell.content.reporttable.rows.reporttablerow[0].cells.reporttablecell', null);
            if (summaryCells) {
                _.each(summaryCells, (cell: any, index: number) => {
                    let cellWidth = '10';
                    switch (index) {
                        case 0: { cellWidth = '35'; break; }
                        case 1: { cellWidth = '15'; break; }
                        case 5: { cellWidth = '20'; break; }
                        default: { cellWidth = '10'; break; }
                    }

                    cell[exportUtil.constants.cell.colWidth] = cellWidth;
                });
            }

            //This code is used to set alignment of Summary Grid columns
            let summaryAllCells = _.get(summarySchema, '[0].rows.reporttablerow[0].cells.reporttablecell.content.reporttable.rows.reporttablerow', null);
            if (summaryAllCells) {
                _.each(summaryAllCells, (cells: any) => {
                    let childCells = _.get(cells, 'cells.reporttablecell', null);
                    if (childCells) {
                        _.each(childCells, (cell: any, index: number) => {
                            let horizontalAlign = exportUtil.enums.horizontalAlign.right;
                            switch (index) {
                                case 0:
                                case 1: horizontalAlign = exportUtil.enums.horizontalAlign.left; break;
                                default: horizontalAlign = exportUtil.enums.horizontalAlign.right; break;
                            }
                            cell[exportUtil.constants.cell.horizontalAlign] = horizontalAlign;
                        });
                    }
                });
            }
        }

        //add summary data
        exportRows.push(self.getGridTableSchemaRow(summarySchema));

        if ((exportType === exportUtil.enums.format.pdf || exportType === exportUtil.enums.format.word) && !self.isReportBuilder) {
            //Add page break
            var pageBreak = exportUtil.getRow(null);
            pageBreak[exportUtil.constants.row.rowType] = exportUtil.enums.rowType.pageBreak;
            exportRows.push(pageBreak);
        }
        else if (exportType === exportUtil.enums.format.excel || exportType === exportUtil.enums.format.html) {
            //add empty row
            emptyRow = exportUtil.getRow(null);
            emptyRow[exportUtil.constants.row.rowType] = exportUtil.enums.rowType.empty;
            exportRows.push(emptyRow);
        }


        // _.each(siries, (charts: any) => {
        var seriesData: Array<any> = [];
        var periodicSeriesData: Array<any> = [];


        //sorting series to place study series next to parent series in export
        let seriesCollection = _.map(data, function (chart: any) { return chart.series; });
        var seriesOfAllPanes = _.flattenDeep(seriesCollection);
        // let sortedSeries = _.sortBy(self.chartControl().series, function (series: any) {
        let sortedSeries = _.sortBy(seriesOfAllPanes, function (series: any) {
            return Math.floor(series.userOptions.id);
        });

        _.each(sortedSeries, function (siri: any) {
            if (siri.userOptions.isPeriodic) {
                periodicSeriesData.push(siri);
            }
            else {
                seriesData.push(siri);
            }
        });

        if (exportType !== exportUtil.enums.format.excel && !self.isReportBuilder) {
            // Annotation
            if (seriesData.length > 0 && _.some(seriesData, function (sd: any) { return sd.name === 'annotation'; })) {
                exportRows.push(self.getGridTableSchemaRow(self.getAnnotationSchema(seriesData, exportType)));

                //add empty row
                emptyRow = exportUtil.getRow(null);
                emptyRow[exportUtil.constants.row.rowType] = exportUtil.enums.rowType.empty;
                exportRows.push(emptyRow);
                exportRows.push(emptyRow);
            }

            //Add Header for Pricing Data
            exportRows.push(exportUtil.getRow(self.getCell('Pane 1', true, true, '8421504', '16777215', 'tableCaption')));
        }

        if ((self.isReportBuilder && exportType === exportUtil.enums.format.excel) || !self.isReportBuilder) {
            if (periodicSeriesData.length > 0) {
                var coninueProcessing = true;
                var processedIndex = [];

                while (coninueProcessing) {
                    var tempSeries = [];
                    for (var i = 0; i < periodicSeriesData.length; i++) {
                        var siri = periodicSeriesData[i];
                        if (processedIndex.indexOf(i) === -1) {
                            if (tempSeries.length === 0) {
                                tempSeries.push(siri);
                                processedIndex.push(i);
                            }
                            else if (tempSeries[0].userOptions.data.length > 0 &&
                                siri.userOptions.data.length > 0 &&
                                self.comparePeriodTypes(tempSeries[0], siri)) {
                                tempSeries.push(siri);
                                processedIndex.push(i);
                            }
                        }

                    }

                    exportRows.push(self.getGridTableSchemaRow(self.chartDataExportSchema(tempSeries, true, exportType)));
                    if (periodicSeriesData.length === processedIndex.length) {
                        coninueProcessing = false;
                    }
                }

                //add empty row
                emptyRow = exportUtil.getRow(null);
                emptyRow[exportUtil.constants.row.rowType] = exportUtil.enums.rowType.empty;
                exportRows.push(emptyRow);
            }
            if (seriesData.length > 0) {
                exportRows.push(self.getGridTableSchemaRow(self.chartDataExportSchema(seriesData, false, exportType)));
            }
        }
        if (self.hasTotalReturn()) {
            //add footnote
            exportRows.push(self.getGridTableSchemaRow(self.footnoteExportSchema()));
        }

        //setup layout
        var gridsDataExportLayoutTable = exportUtil.getTable(exportRows);
        var gridsLayoutCell = exportUtil.getCellAsTable(gridsDataExportLayoutTable);
        gridsLayoutCell[exportUtil.constants.cell.cellType] = exportUtil.enums.cellType.table;
        var tableRows = [];
        tableRows.push(exportUtil.getRow(gridsLayoutCell));
        // build report
        var reportTable = exportUtil.getTable(tableRows);
        reportTable[exportUtil.constants.reportBuilder.style] = 'StyleTable-LeftMargin';  // set margin on the left side
        var jsonReport: any = {
            "@orientation": exportType === exportUtil.enums.format.excel ? exportUtil.enums.orientation.landscape : exportUtil.enums.orientation.portrait,
            "@title": self.tools.entityName ? stringUtilities.format('{0} | {1}', self.title.desc, self.title.subtitle()) : "Chart Builder",
            "reporttable": reportTable,
            "@watermark": true,
            "@browsertitle": ""
        };
        if (exportType === exportUtil.enums.format.excel) {
            // self.findpaneNamebyId(seriesOfAllPanes)
            let paneNumber: number = 0;
            paneNumber = parseInt(indPos) + 1;
            jsonReport[exportUtil.constants.report.excelSheetName] = "Pane " + paneNumber;
            reportCollectionSeries.push(jsonReport);  // push the report
            // Annotation
            if (seriesData.length > 0 && _.some(seriesData, function (sd: any) { return sd.name === 'annotation'; })) {
                reportCollectionSeries.push(self.getAnnotationSchema(seriesData, exportType));
            }
        } else {
            reportCollectionSeries.push(jsonReport);  // push the report
        }
        return reportCollectionSeries;
    }
    public findpaneNamebyId(seriesOfAllPanes: any) {
        let paneId: any;
        let paneName: string = "";
        let chatsInst = self.chartBuilderInstance.panes();
        _.find(seriesOfAllPanes, function (series: any) {
            paneId = series.userOptions.id;
        });
        for (var i = 0; i < chatsInst.length; i++) {
            if (paneId === chatsInst[i].id) {
                paneName = chatsInst[i].name();
            }
        }
        return paneName;
    }
    public getAnnotationSchema(seriesData: any, exportType: any) {
        var annotations = self.getAnnotations(seriesData);
        var annotationColumns: Array<any> = [];
        var gridLayoutTableRows: Array<any> = [];
        annotationColumns.push({ key: 'annotationDate', columnWidth: "10", headerText: 'Date', exportDataFormat: "M/d/yyyy", exportDataType: exportUtil.enums.cellType.datetime, horizontalAlign: exportUtil.enums.horizontalAlign.left, noWrap: exportUtil.enums.noWrap.disable });
        annotationColumns.push({ key: 'annotationType', columnWidth: "30", headerText: 'Type', exportDataFormat: '', exportDataType: exportUtil.enums.cellType.text, horizontalAlign: exportUtil.enums.horizontalAlign.left, noWrap: exportUtil.enums.noWrap.disable });
        annotationColumns.push({ key: 'headline', columnWidth: "60", headerText: 'Headline', exportDataFormat: '', exportDataType: exportUtil.enums.cellType.text, horizontalAlign: exportUtil.enums.horizontalAlign.left, noWrap: exportUtil.enums.noWrap.disable });

        //build header row
        var headerRows = [];
        var headerCells: Array<any> = [];
        var dataRows: Array<any> = [];

        _.forEach(annotations, function (annotation: any) {
            dataRows = [];
            headerRows = [];
            headerCells = [];

            _.forEach(annotationColumns, function (item: any) {
                let cell = self.getCell(item.headerText, true, true, '', '', 'StyleHeaderRow');
                cell[exportUtil.constants.cell.colWidth] = item.columnWidth;
                headerCells.push(cell);
            });

            if (exportType === exportUtil.enums.format.excel) {
                headerRows.push(exportUtil.getRow(null));
            }

            var gridHeaderCell = exportUtil.getCell(annotation.title);
            gridHeaderCell[exportUtil.constants.cell.fontBold] = exportUtil.enums.fontBold.enable;
            gridHeaderCell[exportUtil.constants.cell.colMerge] = "3";
            gridHeaderCell[exportUtil.constants.cell.colSpan] = "3";
            headerRows.push(exportUtil.getRow(gridHeaderCell));
            headerRows.push(exportUtil.getRow(headerCells));

            // Build Table
            var gridTable = exportUtil.getTable([]);

            gridTable[exportUtil.constants.table.setAlternateStyle] = exportUtil.enums.setAlternateStyle.enabled;
            gridTable[exportUtil.constants.table.border] = exportUtil.enums.border.enable;
            gridTable[exportUtil.constants.reportBuilder.style] = 'standardgridtable';
            gridTable.rows.reporttablerow = gridTable.rows.reporttablerow.concat(headerRows);
            var sortedData = _.sortBy(annotation.data, function (data: any) { return data[0]; }).reverse();

            _.forEach(sortedData, function (data: any) {
                var dataCells: Array<any> = [];
                _.forEach(data, function (d: any, c: any) {
                    var jsonCell = exportUtil.getCell(d);
                    jsonCell[exportUtil.constants.cell.numberFormat] = annotationColumns[c].exportDataFormat;
                    jsonCell[exportUtil.constants.cell.cellType] = annotationColumns[c].exportDataType;
                    jsonCell[exportUtil.constants.cell.horizontalAlign] = annotationColumns[c].horizontalAlign;
                    jsonCell[exportUtil.constants.cell.noWrap] = annotationColumns[c].noWrap;
                    if (annotationColumns[c].key === 'annotationType') {
                        jsonCell[exportUtil.constants.cell.colWidth] = 40;
                    }
                    else if (annotationColumns[c].key === 'headline') {
                        jsonCell[exportUtil.constants.cell.colWidth] = 200;
                    }

                    dataCells.push(jsonCell);
                });
                dataRows.push(exportUtil.getRow(dataCells));
            });
            gridTable.rows.reporttablerow = gridTable.rows.reporttablerow.concat(dataRows);

            var gridSchemaCell = exportUtil.getCellAsTable(gridTable);
            gridSchemaCell[exportUtil.constants.cell.cellType] = exportUtil.enums.cellType.table;
            gridLayoutTableRows.push(exportUtil.getRow(gridSchemaCell));
        });
        var annotationTableRow = self.getGridTableSchemaRow(exportUtil.getTable(gridLayoutTableRows));
        var gridsDataExportLayoutTable = exportUtil.getTable([annotationTableRow]);
        var gridsLayoutCell = exportUtil.getCellAsTable(gridsDataExportLayoutTable);
        gridsLayoutCell[exportUtil.constants.cell.cellType] = exportUtil.enums.cellType.table;
        var tableRows = [];
        tableRows.push(self.getGridTableSchemaRow(self.chartExportSchema()));
        if (exportType !== exportUtil.enums.format.excel) {
            tableRows.push(exportUtil.getRow(self.getCell('Annotations', true, true, '8421504', '16777215', 'tableCaption')));
            tableRows.push(exportUtil.getRow(gridsLayoutCell));
            return exportUtil.getTable(tableRows);
        } else {
            tableRows.push(exportUtil.getRow(gridsLayoutCell));
            var reportTable = exportUtil.getTable(tableRows);

            reportTable[exportUtil.constants.reportBuilder.style] = 'StyleTable-LeftMargin';  // set margin on the left side
            var jsonReport: any = {
                "@orientation": exportUtil.enums.orientation.landscape,
                "@title": "Key Development Annotations",
                "reporttable": reportTable,
                "@watermark": true,
                "@browsertitle": ""
            };
            jsonReport[exportUtil.constants.report.excelSheetName] = "Key Developments";

            return jsonReport;
        }
    }

    public getAnnotations(seriesData: any) {
        var annotations: Array<any> = [];
        var annotationSeries = _.pluck(_.filter(seriesData, function (series: any) {
            return series.name === 'annotation';
        }), 'userOptions');

        var dateRange = self.chartBuilderInstance.chartDateRange();

        var startDate = Date.parse(dateRange.start.slice(0, 4) + "/" + dateRange.start.slice(4, 6) + "/" + dateRange.start.slice(6, 8));
        var endDate = Date.parse(dateRange.end.slice(0, 4) + "/" + dateRange.end.slice(4, 6) + "/" + dateRange.end.slice(6, 8));

        var plottedDateRange = self.chartBuilderInstance.plottedDateRange();
        if (plottedDateRange) {
            startDate = Date.parse(plottedDateRange.start.slice(0, 4) + "/" + plottedDateRange.start.slice(4, 6) + "/" + plottedDateRange.start.slice(6, 8));
            endDate = Date.parse(plottedDateRange.end.slice(0, 4) + "/" + plottedDateRange.end.slice(4, 6) + "/" + plottedDateRange.end.slice(6, 8));
        }

        annotationSeries.map(function (series: any) {
            series.points = series.data.filter(function (point: any) {
                return point.x >= startDate && point.x <= endDate;
            });
        });

        _.each(annotationSeries, function (series: any) {
            var annotation: any = {};

            var title = series.entity.companyTradingSymbol + '-' + series.metric.localizedCaption;
            var existingAnnotation = _.some(annotations, function (annotation: any) { return annotation.title === title; });
            if (existingAnnotation) {
                annotation = _.find(annotations, function (ann: any) { return ann.title === title; });
            }
            else {
                annotation.title = title;
                annotation.data = [];
            }

            _.map(series.points, function (point: any) {
                _.forEach(point.values, (val: any) => {
                    annotation.data.push([
                        moment(new Date(point.x)).format("YYYY-MM-DD"),
                        val.type.name,
                        val.text
                    ]);
                });
            });

            if (!existingAnnotation) {
                annotations.push(annotation);
            }
        });

        return annotations;
    }

    public chartDataExportSchema(seriesData: any, isPeriodic?: any, exportType: any = exportUtil.enums.format.excel): GridInterfaces.ITable {
        var data: any = {};
        var columns: Array<any> = [];
        var columnsCount = 1;
        var exportDateFormat = "M/d/yyyy";

        let hasIntradayData = _.any(seriesData, (siri: any) => intraday.isIntradayCapableSeries(siri.userOptions.entity.contentSet, siri.userOptions.metric.key, siri.userOptions.metric.secondaryKeys));

        if (hasIntradayData) {
            exportDateFormat = exportDateFormat + ' HH:mm';
        }


        columns.push({
            key: 'column0',
            headerText: 'Pricing Date',
            exportDataFormat: exportDateFormat,
            exportDataType: exportUtil.enums.cellType.datetime,
            horizontalAlign: exportUtil.enums.horizontalAlign.left,
            noWrap: exportUtil.enums.noWrap.disable
        });

        var seriesDataSansAnno = _.filter(seriesData, function (siri: any) {
            return siri.name !== "annotation";
        });
        //var formats = _.map(seriesDataSansAnno, function (siri: any) {
        //    var type = siri.yAxis.userOptions.numberFormat.type;
        //    var format = siri.yAxis.userOptions.numberFormat.format;

        //    return type === "custom" ? format : "default";
        //});
        var formats: any[] = [];
        _.forEach(seriesDataSansAnno, function (siri: any) {
            let type: any = siri.yAxis.userOptions.numberFormat.type;
            let format: any = siri.yAxis.userOptions.numberFormat.format;
            let isCandlestick: boolean = _.contains(['candlestick', 'ohlc'], siri.userOptions.type.toLowerCase());

            if (isCandlestick) {
                formats.push(type === "custom" ? format : "default"); //open
                formats.push(type === "custom" ? format : "default"); //high
                formats.push(type === "custom" ? format : "default"); //low
            }
            formats.push(type === "custom" ? format : "default");
        });

        _.map(seriesDataSansAnno, function (serieData: any, k: any) {
            var chartData;
            let isCandlestick: boolean = _.contains(['candlestick', 'ohlc'], serieData.userOptions.type.toLowerCase());
            if (serieData.hasGroupedData !== undefined && serieData.hasGroupedData === true) {
                chartData = serieData.groupedData;
            } else {
                chartData = serieData.userOptions.data;
            }
            let seriesId = serieData.options.id;
            let metric = serieData.options.metric;
            var currChart = gUtils.findHighchartById(self.view, _.get(self.firstPane(), 'chartId'));
            if (currChart.resetZoomButton) {
                chartData = _.filter(chartData, function (cd: any) {
                    return cd.x >= currChart.xAxis[0].min && cd.x <= currChart.xAxis[0].max;
                });
            }
            var serieDates: Array<any> = [];
            _.each(chartData, function (point: any) {
                if (point !== undefined && !_.contains(serieDates, point.x)) {
                    //modifying the time in milliseconds for candlestick type series
                    point.x = isCandlestick || gUtils.isEstimate(serieData.userOptions.metric) ? gUtils.getZeroTimeWithDate(point.x) : point.x;
                    let pointX = point.x;
                    serieDates.push(pointX);
                    var fix = false;
                    fix = ((data[pointX] === undefined && k > 0) ||
                        (data[pointX] !== undefined && data[pointX].length < k) ||
                        (data[pointX] !== undefined && data[pointX].length !== 0 && data[pointX].length > k));
                    if (fix) {
                        if (data[pointX] === undefined && k > 0) {
                            data[pointX] = [];
                        }
                        while (data[pointX].length < columnsCount - 1) {
                            data[pointX].push(null);
                        }
                    }
                    let price;
                    let priceLow;
                    let priceHigh;
                    let priceOpen;

                    //if it is candlestick/ohlc _price will be close price
                    price = isCandlestick ? (!gUtils.isNullOrUndefined(point.close) ? point.close : null) : (!gUtils.isNullOrUndefined(point.y) ? point.y : null);

                    if (isCandlestick) {// applicable only for candlestick/ohlc
                        priceOpen = point.open ? point.open : null;
                        priceHigh = point.high ? point.high : null;
                        priceLow = point.low ? point.low : null;
                    }

                    if (exportType !== exportUtil.enums.format.excel) {
                        let checkMagnitude = formats[columnsCount - 1];
                        if (checkMagnitude && checkMagnitude !== 'default' && checkMagnitude !== 'actual') {
                            let itemCell = price;
                            if (itemCell === "NA") {
                                itemCell = null;
                            }
                            itemCell = itemCell == null ? webStrings.nA() : isNaN(itemCell) ? webStrings.nM() : itemCell;
                            let formattedYValue = isNaN(itemCell) ? webStrings.nM() : gUtils.formatValueWithMagnitude(itemCell, '', metric, seriesId);
                            price = formattedYValue;
                        }
                    }

                    if (data[pointX] !== undefined) {
                        if (!isCandlestick) {
                            data[pointX].push(price);
                        }
                        else {
                            data[pointX].push(priceOpen, priceHigh, priceLow, price);
                        }
                    }
                    else {
                        data[pointX] = isCandlestick ? [priceOpen, priceHigh, priceLow, price] : [price];
                    }
                }
            });
            _.forIn(data, function (value: any, key: any) {
                if (_.includes(serieDates, parseInt(key)) === false) {
                    if (!isCandlestick) {
                        value.push(webStrings.nA());
                    }
                    else {
                        value.push(webStrings.nA());
                        value.push(webStrings.nA());
                        value.push(webStrings.nA());
                        value.push(webStrings.nA());
                    }
                }
            });
            var col = 'column' + columnsCount;// change the count

            var checkMagnitude = formats[columnsCount - 1];
            let magnitude = serieData.userOptions.data.length !== 0 ? (serieData.userOptions.data[0].meta.mag || '').replace('(actual)', '').replace(/[{()}]/g, '') : '';
            var titleCase = function toTitleCase(str: any) {
                return str.replace(/(?:^|\s)\w/g, function (match: any) {
                    return match.toUpperCase();
                });
            };
            if (magnitude.length > 0) {
                if (checkMagnitude && checkMagnitude !== 'default' && checkMagnitude !== 'actual') {
                    magnitude = magnitude.replace('000', titleCase(checkMagnitude));
                }
                else {
                    magnitude = magnitude.replace('000', '');
                }
            }

            var serieDataName = gUtils.isEstimate(serieData.userOptions.metric) || gUtils.isForward(serieData.userOptions.metric) ?
                gUtils.formatEstimateSeriesName((serieData.userOptions.customName || serieData.name), serieData.userOptions.periodType, serieData.userOptions.offset)
                : (serieData.userOptions.customName || serieData.name);

            var seriesName = magnitude.length === 0 ? serieDataName : stringUtilities.format("{0}({1})", serieDataName, magnitude);
            let seriesNamesForCandleStick: string[] =
                [
                    magnitude.length === 0 ? serieData.name : stringUtilities.format("{0}({1})", serieData.userOptions.entity.companyTradingSymbol + '-' + 'Day Open Price', magnitude),
                    magnitude.length === 0 ? serieData.name : stringUtilities.format("{0}({1})", serieData.userOptions.entity.companyTradingSymbol + '-' + 'Day High Price', magnitude),
                    magnitude.length === 0 ? serieData.name : stringUtilities.format("{0}({1})", serieData.userOptions.entity.companyTradingSymbol + '-' + 'Day Low Price', magnitude)
                ];

            let exportFormat = exportType === exportUtil.enums.format.excel ? '#,##0.00' : ((checkMagnitude && checkMagnitude !== 'default' && checkMagnitude !== 'actual') ? '' : '#,##0.00');
            if (isCandlestick) {
                seriesNamesForCandleStick.push(seriesName);// pushing dayclose price at last
                //push all 4 columns
                for (let eachSeriName of seriesNamesForCandleStick) {
                    columns.push({
                        key: 'column' + columnsCount,
                        headerText: eachSeriName,
                        exportDataFormat: exportFormat,
                        exportDataType: exportUtil.enums.cellType.number,
                        horizontalAlign: exportUtil.enums.horizontalAlign.right,
                        noWrap: exportUtil.enums.noWrap.disable
                    });

                    columnsCount++;
                }
            } else {
                columns.push({
                    key: col,
                    headerText: seriesName,
                    exportDataFormat: exportFormat,
                    exportDataType: exportUtil.enums.cellType.number,
                    horizontalAlign: exportUtil.enums.horizontalAlign.right,
                    noWrap: exportUtil.enums.noWrap.disable
                });
            }

            columnsCount = isCandlestick ? columnsCount : columnsCount + 1;
        });

        var results = _.map(data, function (v: any, k: any) {
            var date = new Date(Number(k));
            var value = [date];
            return value.concat(v);
        });

        //Sort Results by Date
        results = results.sort(function (a: any, b: any) {
            return b[0] - a[0];
        });

        // build data table
        var gridTable = exportUtil.getTable([]);
        gridTable[exportUtil.constants.table.setAlternateStyle] = exportUtil.enums.setAlternateStyle.enabled;
        gridTable[exportUtil.constants.table.border] = exportUtil.enums.border.enable;
        gridTable[exportUtil.constants.reportBuilder.style] = 'standardgridtable';

        //build header row
        var headerRows = [];
        var headerCells: Array<any> = [];
        _.forEach(columns, function (item: any, key: any) {
            if (exportType === exportUtil.enums.format.excel) {
                headerCells.push(exportUtil.getBoxHeaderCell(item.headerText, 0));
            }
            else {
                if (key === 0) {
                    headerCells.push(self.getCell(item.headerText, true, true, '', '', 'StyleHeaderRow'));
                } else {
                    let cell = self.getCell(item.headerText, true, true, '', '', 'StyleHeaderRow');
                    cell[exportUtil.constants.cell.horizontalAlign] = exportUtil.enums.horizontalAlign.right;
                    headerCells.push(cell);
                }
            }
        });

        headerRows.push(exportUtil.getRow(headerCells));
        gridTable.rows.reporttablerow = gridTable.rows.reporttablerow.concat(headerRows);

        let today = new Date();
        today.setHours(0, 0, 0, 0);

        //build data rows
        var dataRows: Array<any> = [];
        _.forEach(results, function (itemRow: any) {
            var dataCells: Array<any> = [];
            _.forEach(itemRow, function (itemCell: any, c: any) {
                if (c <= columns.length - 1) {
                    let exportDataFormat = columns[c].exportDataFormat;
                    if (c === 0) {
                        itemCell = isPeriodic ? self.getPeriodicLabel(seriesDataSansAnno, itemCell) :
                            common.isOffice ? localizationUtility.getLocalizedDate(itemCell, localizationUtility.dateFormat("d"), "en-US") :
                                intraday.getPlottedDateTime(new Date(itemCell).getTime(), 'MM/DD/YYYY' + (hasIntradayData || new Date(itemCell).getTime() >= today.getTime() ? ' HH:mm' : ''));

                        exportDataFormat = isPeriodic || common.isOffice ? exportDataFormat : exportDataFormat + (hasIntradayData || new Date(itemCell).getTime() >= today.getTime() ? ' HH:mm' : '');
                    }
                    else {
                        // If value is not a number (NaN), set it to 'NM'
                        // If null, set it to 'NA'
                        // Else set to actual value
                        if (exportType === exportUtil.enums.format.excel || exportDataFormat !== '') {
                            if (itemCell === "NA") {
                                itemCell = null;
                            }
                            itemCell = itemCell == null ? webStrings.nA() :
                                isNaN(itemCell) ? webStrings.nM() :
                                    itemCell;

                            var cellLocalizeNumberValue = localizationUtility.parseFloat(itemCell);
                            itemCell = isNaN(cellLocalizeNumberValue) ? itemCell : cellLocalizeNumberValue;

                            //let isCandlestickColumn: boolean = columns[c].headerText.contains('Day Close Price')
                            //    || columns[c].headerText.contains('Day Low Price')
                            //    || columns[c].headerText.contains('Day High Price');

                            if (!isNaN(cellLocalizeNumberValue)) {
                                //exportDataFormat = excelDecimalNumberFormats[isCandlestickColumn ? formats[0] : formats[c - 1]];
                                exportDataFormat = excelDecimalNumberFormats[formats[c - 1]];
                                exportDataFormat = cellLocalizeNumberValue.toString().indexOf('.') >= 0 ? exportDataFormat : (exportDataFormat ? exportDataFormat.replace('.00', '') : undefined);
                            }
                        }

                        //check for canlde stick column
                        //itemCell = getExcelNumberAsString(itemCell);
                    }
                    var jsonCell = exportUtil.getCell(itemCell);
                    jsonCell[exportUtil.constants.cell.numberFormat] = exportDataFormat;
                    jsonCell[exportUtil.constants.cell.cellType] = columns[c].exportDataType;
                    jsonCell[exportUtil.constants.cell.horizontalAlign] = columns[c].horizontalAlign;
                    jsonCell[exportUtil.constants.cell.noWrap] = columns[c].noWrap;
                    dataCells.push(jsonCell);
                }
            }, columns);
            dataRows.push(exportUtil.getRow(dataCells));
        }, columns);
        gridTable.rows.reporttablerow = gridTable.rows.reporttablerow.concat(dataRows);

        var gridLayoutTableRows = [];
        var gridSchemaCell = exportUtil.getCellAsTable(gridTable);
        gridSchemaCell[exportUtil.constants.cell.cellType] = exportUtil.enums.cellType.table;
        gridLayoutTableRows.push(exportUtil.getRow(gridSchemaCell));

        return exportUtil.getTable(gridLayoutTableRows);
    }

    /***  Get cell schema for exports
    * @param content, isBold, noWrap, colorBackground, fontColor, className
    * @returns
    */
    public getCell(content: string, isBold: boolean, noWrap: boolean, colorBackground?: string, fontColor?: string, className?: string): GridInterfaces.ICell {
        let cell = exportUtil.getCell(content);

        if (isBold) {
            cell[exportUtil.constants.cell.fontBold] = exportUtil.enums.fontBold.enable;
        }

        if (noWrap === false) {
            cell[exportUtil.constants.cell.noWrap] = exportUtil.enums.noWrap.disable;
        }

        if (colorBackground) {
            cell[exportUtil.constants.cell.colorBackground] = colorBackground;
        }

        if (fontColor) {
            cell[exportUtil.constants.cell.fontColor] = fontColor;
        }

        if (className) {
            cell[exportUtil.constants.cell.cssClass] = className;
        }
        return cell;
    }

    public getFilterExportSchema(): GridInterfaces.ITable {
        // build table
        let table = exportUtil.getTable([]);

        //filterSettingsHeaderCells to adjust cell's width
        let filterSettingsHeaderCells: Array<GridInterfaces.ICell> = [];
        let cell = exportUtil.getCell("");

        filterSettingsHeaderCells.push(cell);

        // add few properties to table
        table.rows.reporttablerow.push(exportUtil.getRow(filterSettingsHeaderCells));

        //row:1 Entities Name
        let sortedData = self.chartBuilderInstance.panes()[0].seriesCollection().sort((x: any, y: any) => x.entity.sequenceId - y.entity.sequenceId);
        // added if it is Benchmark series showing '/' instead of ',' Need to verify these changes....
        sortedData = _.filter(sortedData, function (series: any) { return !series.isBenchMark === true; });
        let entitiesText = _.uniq(_.pluck(sortedData, 'entity.companyShortName')).join(', ');
        let contentCells = [self.getCell('<strong>Entities: </strong>' + entitiesText, false, true)];
        //push cells to row
        table.rows.reporttablerow.push(exportUtil.getRow(contentCells));

        //row:1 Metric Name
        let metricText = _.uniq(_.pluck(self.chartBuilderInstance.panes()[0].seriesCollection(), 'metric.localizedCaption')).join(', ');
        contentCells = [self.getCell('<strong>Metrics: </strong>' + metricText, false, true)];

        //push cells to row
        table.rows.reporttablerow.push(exportUtil.getRow(contentCells));

        return table;
    }

    public getGridTableSchemaRow(gridSchema: any): GridInterfaces.IRow {
        var gridTableCell = exportUtil.getCellAsTable(gridSchema);
        gridTableCell[exportUtil.constants.cell.cellType] = exportUtil.enums.cellType.table;
        return exportUtil.getRow(gridTableCell);
    }

    public successCallBack(response: any) {
        if (response.Success === true) {
            let fileNameTimestamp = getlocalizedDateStringInvariant(moment(), common.culture()) + moment().format(' h:mm:ss a');
            let fileName = 'Chart_' + fileNameTimestamp;
            let baseFilePath = stringUtilities.format('{0}{1}{2}', common.config.uris.data.export.v2, 'Retrieve?filename=', response.Message);
            if (response.Message.indexOf(".xlsx") > -1) {
                baseFilePath += '&exportFileName=' + fileName + '.xlsx';
            }
            else if (response.Message.indexOf(".pdf") > -1) {
                fileName = stringUtilities.format('{0}{1}', (self.isStockChartModeEnabled ? stringUtilities.format('{0}_{1}', self.title.desc, self.title.subtitle()) : "Chart Builder"), fileNameTimestamp);
                baseFilePath += '&exportFileName=' + fileName + '.pdf';
            }

            if (common.isOffice) {
                self.officeExportChart.reportUrl = stringUtilities.format('{0}{1}{2}{3}', window.location.protocol, '//', window.location.host, baseFilePath);
            }
            else {
                window.open(baseFilePath);
            }
        }
        else {
            zone.root.notify({
                message: response.responseJSON.Message,
                type: "error",
                dismiss: true
            });
        }
    }

    public errorCallBack(response: any) {
        zone.root.notify({
            message: response.responseJSON.Message,
            type: "error",
            dismiss: true
        });
    }

    public addBenchMark(benchMarkData: any, parentData: any) {
        var parentSeries = _.find(self.chartBuilderInstance.panes()[0].seriesCollection(), function (series: any) {
            return series.id === parentData.data.id || parentData.id;
        });
        if (parentSeries) {
            //add bench mark entity to parent series
            if (parentSeries.benchMarkEntities && parentSeries.benchMarkEntities.length === 0) {
                var indexEntityObj: any = {
                    companyExchange: undefined,
                    companyShortName: benchMarkData[0].name,
                    companySnlKeyInstn: undefined,
                    companyTradingItemId: undefined,
                    companyTradingSymbol: undefined,
                    companyTradingSymbolExchange: undefined,
                    contentSet: 6,
                    entityTypeFct: "indices",
                    id: benchMarkData[0].id,
                    isPreserved: undefined,
                    isStaticEntity: false,
                    keyUniversalEntity: benchMarkData[0].keyUniversalEntity,
                    magnitude: undefined,
                    name: benchMarkData[0].name,
                    title: "",
                    tradingItemID: undefined
                };
                parentSeries.benchMarkEntities.push(indexEntityObj);
                if (parentSeries.metric.key === 290930) {
                    parentSeries.metric.localizedCaption = 'Share Price';
                }
                let benchmarkedSeriesName = gUtils.formatSeriesName(parentSeries.entity, parentSeries.metric, null, parentSeries);
                self.updateSeriesName(parentSeries.id, benchmarkedSeriesName, parentSeries.paneId);
            }

            var newBenchMarkSeries: CBModels.Series = {
                annotations: [],
                chartType: parentSeries.type,
                color: parentSeries.color,
                data: [],
                entity: indexEntityObj || parentSeries.benchMarkEntities[0],
                id: self.getSeriesId(),
                isIndividual: parentSeries.isIndividual,
                isPeriodic: false,
                isVisible: parentSeries.isVisible,
                metric: parentSeries.metric,
                name: benchMarkData.name,
                paneId: parentSeries.paneId,
                periodType: parentSeries.periodType,
                xAxis: parentSeries.xAxis,
                yAxisId: parentSeries.yAxisId,
                currency: parentSeries.currency,
                isStudy: false,
                studyType: "",
                studyPeriod: 0,
                studyStdDev: 0,
                studySeqId: 0,
                indexDate: null,
                fontSettings: parentSeries.fontSettings ? ko.observable(parentSeries.fontSettings) : ko.observable(CBModels.makeFontSettings()),
                offset: parentSeries.offset,
                orignalData: parentSeries.orignalData ? parentSeries.orignalData : [],
                ohlsData: parentSeries.orignalData ? parentSeries.orignalData : [],
                isCallByTimeframe: false,
                dataLabelsFontSettings: parentSeries.dataLabelsFontSettings ? parentSeries.dataLabelsFontSettings : CBModels.makeFontSettings(),
                selectedDataLabelOptions: parentSeries.selectedDataLabelOptions ? parentSeries.selectedDataLabelOptions : [],
                isBenchMark: true,
                benchMarkEntities: [],
                parentSeriesId: parentSeries.id,
                isFrequencyUpdated: false,
                lineWidth: parentSeries.lineWidth,
                dashStyle: parentSeries.dashStyle,
                studySeriesIds: []

            };
            self.addSeries([newBenchMarkSeries]);
        }
    }

    public removeBenchmark(parentSeries: any) {
        let currChart = gUtils.findHighchartById(self.view, _.get(self.firstPane(), 'chartId'));
        let relatedIndexSeries = _.find(self.chartBuilderInstance.panes()[0].seriesCollection(), function (series: any) {
            return !series.isStudy && series.parentSeriesId === parentSeries.id;
        });

        //Removing benchmark(index) series from series collection
        self.firstPane().seriesCollection.remove(function (series: any) {
            return series.id === relatedIndexSeries.id;
        });

        if (self.actualData().length > 0) {
            self.actualData.remove(function (series: any) {
                return series.id === relatedIndexSeries.id;
            });
        }
        let firstPaneYAxisCollection = self.firstPane().yAxisCollection;
        let targetYAxisObject = gUtils.findYAxisObjectbyId(firstPaneYAxisCollection(), relatedIndexSeries.yAxis);
        if ((!targetYAxisObject) && (relatedIndexSeries.axis) && (relatedIndexSeries.axis.yAxis)) {      // To Do : Remove this : Adding fix for series manager: remove all
            targetYAxisObject = gUtils.findYAxisObjectbyId(firstPaneYAxisCollection(), relatedIndexSeries.axis.yAxis);
        }
        if (targetYAxisObject) {
            targetYAxisObject.seriesIds = _.remove(targetYAxisObject.seriesIds, function (id: any) {
                return id !== relatedIndexSeries.id;
            });
        }

        parentSeries.benchMarkEntities = [];

        let defaultSeriesName = gUtils.formatSeriesName(parentSeries.entity, parentSeries.metric, null, null);
        self.updateSeriesName(parentSeries.id, defaultSeriesName, parentSeries.paneId);

        _.each(currChart.series, function (s) {
            if (s.userOptions.id === parentSeries.id) {
                s.userOptions.benchMarkEntities = [];
                s.userOptions.customName = undefined;
            }
        });
        parentSeries.name = undefined;
        self.updateSeriesFromTimeFrame(true, undefined, true, [parentSeries]);
        gUtils.removeBenchMarkPlotLine(currChart);
    }

    public addStudiesCB(e: any, fromEdit: boolean = false) {
        var parentSeries = e.series;
        var studySeries: any[] = [];
        let study = e.study;
        let studyOptions = study.studyOptions;
        let studyPaneId = parentSeries.paneId;
        // removes duplicate study periods
        if (fromEdit && (study.type === gUtils.StudyType.BB || study.type === gUtils.StudyType.MACD)) {
            studyOptions.periods = study.studyOptions.periods;
        } else {
            studyOptions.periods = gUtils.removeDuplicateStudyPeriods(parentSeries, study.type, _.uniq(studyOptions.periods), studyOptions.stdDev, study.studySeqIds);
        }
        if (studyOptions.periods.length > 0 && gUtils.plottedInChildPane(study.type)) {
            if (!fromEdit) {
                studyPaneId = self.getPaneId();
            }
            else {
                let firstEditedMACDSeries = _.find(self.allPanesSeriesArr(), function (series: any) {
                    return series.isStudy && series.studyType === gUtils.StudyType.MACD &&
                        series.entity.companySnlKeyInstn === parentSeries.entity.companySnlKeyInstn && series.paneId > 1;
                });
                studyPaneId = firstEditedMACDSeries ? _.get(firstEditedMACDSeries, 'paneId') : self.getPaneId();
            }
        }

        if (study.studyOptions && study.studyOptions.mulPeriods.length > 1) {
            _.each(studyOptions.mulPeriods, (period) => {
                var newStudySeries: CBModels.Series = {
                    annotations: [],
                    chartType: gUtils.getStudyChartType(study.type, 0),
                    color: period.color(),//"", // will update the correct seriesId in addSeries function
                    data: [],
                    entity: parentSeries.entity,
                    //  id: parentSeries.id,  // will update the correct seriesId in addSeries function
                    id: self.getSeriesId(),  // will update the correct seriesId in addSeries function
                    isIndividual: parentSeries.isIndividual,
                    isPeriodic: gUtils.isStudyOnDayClosePrice(study.type) ? false : parentSeries.isPeriodic,
                    isVisible: parentSeries.isVisible,
                    metric: gUtils.isStudyOnDayClosePrice(study.type) && parentSeries.entity.contentSet !== 7 && parentSeries.entity.contentSet !== 86 ? dayClosePrice :
                        (parentSeries.entity.contentSet === 86 && parentSeries.metric.key !== 319624) ? settlementPrice : parentSeries.metric,
                    name: period.name() || studyOptions.seriName,//formationUtil.getFormattedStudySeriesName(parentSeries.entity, parentSeries.metric, study.type, period, studyOptions.stdDev, seqId),
                    paneId: studyPaneId,
                    periodType: parentSeries.periodType,
                    xAxis: parentSeries.xAxis,
                    yAxisId: studyPaneId === parentSeries.paneId ? parentSeries.yAxisId : "",
                    currency: parentSeries.currency,
                    isStudy: true,
                    studyType: study.type,
                    studyPeriod: period.value,
                    studyStdDev: studyOptions.stdDev,
                    studySeqId: 0,
                    indexDate: null,
                    fontSettings: parentSeries.fontSettings ? ko.observable(parentSeries.fontSettings) : ko.observable(CBModels.makeFontSettings()),
                    offset: parentSeries.offset,
                    orignalData: parentSeries.orignalData ? parentSeries.orignalData : [],
                    ohlsData: parentSeries.orignalData ? parentSeries.orignalData : [],
                    isCallByTimeframe: false,
                    dataLabelsFontSettings: parentSeries.dataLabelsFontSettings ? parentSeries.dataLabelsFontSettings : CBModels.makeFontSettings(),
                    selectedDataLabelOptions: parentSeries.selectedDataLabelOptions ? parentSeries.selectedDataLabelOptions : [],
                    isBenchMark: false,
                    benchMarkEntities: [],
                    parentSeriesId: parentSeries.id,
                    isFrequencyUpdated: parentSeries.isFrequencyUpdated,
                    lineWidth: parentSeries.lineWidth,
                    dashStyle: parentSeries.dashStyle ? parentSeries.dashStyle : "Solid",
                    studySeriesIds: []
                };
                studySeries.push(newStudySeries);
                parentSeries.studySeriesIds.push(newStudySeries.id);

            });
        } else {
            Object.keys(study.studySeqIds).forEach(function (key: any) {
                _.each(studyOptions.periods, (period) => {
                    var newStudySeries: CBModels.Series = {
                        annotations: [],
                        chartType: gUtils.getStudyChartType(study.type, parseInt(key)),
                        color: study.studySeqIds[key].color || studyOptions.color,//"", // will update the correct seriesId in addSeries function
                        data: [],
                        entity: parentSeries.entity,
                        //  id: parentSeries.id,  // will update the correct seriesId in addSeries function
                        id: self.getSeriesId(),  // will update the correct seriesId in addSeries function
                        isIndividual: parentSeries.isIndividual,
                        isPeriodic: gUtils.isStudyOnDayClosePrice(study.type) ? false : parentSeries.isPeriodic,
                        isVisible: parentSeries.isVisible,
                        metric: gUtils.isStudyOnDayClosePrice(study.type) && parentSeries.entity.contentSet !== 7 && parentSeries.entity.contentSet !== 86 ? dayClosePrice :
                            (parentSeries.entity.contentSet === 86 && parentSeries.metric.key !== 319624) ? settlementPrice : parentSeries.metric,
                        name: _.isEmpty(study.studySeqIds[key].name) && _.isEmpty(studyOptions.seriName) ? formationUtil.getFormattedStudySeriesName(parentSeries.entity, parentSeries.metric, study.type, period, studyOptions.stdDev, parseInt(key))
                            : study.studySeqIds[key].name || studyOptions.seriName,//formationUtil.getFormattedStudySeriesName(parentSeries.entity, parentSeries.metric, study.type, period, studyOptions.stdDev, seqId),
                        paneId: studyPaneId,
                        periodType: parentSeries.periodType,
                        xAxis: parentSeries.xAxis,
                        yAxisId: studyPaneId === parentSeries.paneId ? parentSeries.yAxisId : "",
                        currency: parentSeries.currency,
                        isStudy: true,
                        studyType: study.type,
                        studyPeriod: period,
                        studyStdDev: studyOptions.stdDev,
                        studySeqId: (study.type === gUtils.StudyType.BB || study.type === gUtils.StudyType.MACD) ? study.studySeqIds[key].id : parseInt(key),
                        indexDate: null,
                        fontSettings: parentSeries.fontSettings ? ko.observable(parentSeries.fontSettings) : ko.observable(CBModels.makeFontSettings()),
                        offset: parentSeries.offset,
                        orignalData: parentSeries.orignalData ? parentSeries.orignalData : [],
                        ohlsData: parentSeries.orignalData ? parentSeries.orignalData : [],
                        isCallByTimeframe: false,
                        dataLabelsFontSettings: parentSeries.dataLabelsFontSettings ? parentSeries.dataLabelsFontSettings : CBModels.makeFontSettings(),
                        selectedDataLabelOptions: parentSeries.selectedDataLabelOptions ? parentSeries.selectedDataLabelOptions : [],
                        isBenchMark: false,
                        benchMarkEntities: [],
                        parentSeriesId: parentSeries.id,
                        isFrequencyUpdated: false,
                        lineWidth: parentSeries.lineWidth,
                        dashStyle: parentSeries.dashStyle ? parentSeries.dashStyle : "Solid",
                        studySeriesIds: []
                    };
                    studySeries.push(newStudySeries);
                    parentSeries.studySeriesIds.push(newStudySeries.id);
                });
            });
        }
        self.addSeries(studySeries);
    }

    public editStudiesCB(editSeriesOptions: any) {
        // TO-DO: needs to enable study type change when editing
        if (editSeriesOptions.removableStudySeries.length > 0) {
            self.removeSeries(editSeriesOptions.removableStudySeries, false, false);
        }
        if (gUtils.isStudyOnDayClosePrice(editSeriesOptions.currentSeries.studyType) && editSeriesOptions.currentSeries.entity.contentSet !== 7) {
            editSeriesOptions.currentSeries.metric = dayClosePrice;
        }
        self.updateSeriesName(editSeriesOptions.currentSeries.id, editSeriesOptions.currentSeries.name, editSeriesOptions.currentSeries.paneId);
        self.updateSeriesColor(editSeriesOptions.currentSeries.id, editSeriesOptions.currentSeries.color, editSeriesOptions.currentSeries.paneId);
        //To update line width of selected line series.
        self.updateLineSeriesWidthOrStyle(editSeriesOptions.currentSeries.id, editSeriesOptions.currentSeries.lineWidth, editSeriesOptions.currentSeries.dashStyle, true, editSeriesOptions.currentSeries.paneId);
        //To update line style of selected line series.
        self.updateLineSeriesWidthOrStyle(editSeriesOptions.currentSeries.id, editSeriesOptions.currentSeries.lineWidth, editSeriesOptions.currentSeries.dashStyle, false, editSeriesOptions.currentSeries.paneId);
        self.updateSeriesFromTimeFrame(true, undefined, true, [editSeriesOptions.currentSeries]);  // To Do : remove parent series from editable collection
        self.actualData.remove(function (series: any) {
            return series.id === editSeriesOptions.currentSeries.id;
        });
        //self.updateStudySeriesId(editSeriesOptions.currentSeries.id, editSeriesOptions.editedStudyId, editSeriesOptions.currentSeries.paneId);
        self.updateStudyType(editSeriesOptions.editedStudyId, editSeriesOptions.currentSeries.paneId);
        let currentSeries = editSeriesOptions.currentSeries;
        //Handling edit with child panes
        let studyPaneId = 1;
        if (gUtils.plottedInChildPane(currentSeries.studyType) && currentSeries.paneId === 1) {
            if (currentSeries.studyType === gUtils.StudyType.RSI || currentSeries.studyType === gUtils.StudyType.SD
                || currentSeries.studyType === gUtils.StudyType.ROC || currentSeries.studyType === gUtils.StudyType.OBV) {
                studyPaneId = self.getPaneId();
            }
            else if (currentSeries.studyType === gUtils.StudyType.MACD) {
                let firstEditedMACDSeries = _.find(self.allPanesSeriesArr(), function (series: any) {
                    return series.isStudy && series.studyType === gUtils.StudyType.MACD &&
                        series.entity.companySnlKeyInstn === currentSeries.entity.companySnlKeyInstn && series.paneId > 1;
                });
                studyPaneId = firstEditedMACDSeries ? _.get(firstEditedMACDSeries, 'paneId') : self.getPaneId();
            }
            if (currentSeries.paneId !== studyPaneId) {
                self.updateStudyPaneId(currentSeries.id, currentSeries.paneId, studyPaneId);
            }
            self.firstPane().seriesCollection.remove(function (series: any) {
                return series.id === currentSeries.id;
            });
            self.removeHighchartSeries([currentSeries.id], [1]);
            currentSeries.isCallByTimeframe = false;
            currentSeries.metric = gUtils.isStudyOnDayClosePrice(currentSeries.studyType) && currentSeries.entity.contentSet !== 7 ? dayClosePrice : currentSeries.metric;
            currentSeries.chartType = gUtils.getStudyChartType(currentSeries.studyType, currentSeries.studySeqId);
            //  currentSeries.yAxis = "";
            self.addSeries([currentSeries]);
        }
        else if (!gUtils.plottedInChildPane(currentSeries.studyType) && currentSeries.paneId > 1) {
            let currentSeriesPaneId = currentSeries.paneId;
            self.updateStudyPaneId(currentSeries.id, currentSeriesPaneId, 1);
            currentSeries.isCallByTimeframe = false;
            currentSeries.metric = gUtils.isStudyOnDayClosePrice(currentSeries.studyType) && currentSeries.entity.contentSet !== 7 ? dayClosePrice : currentSeries.metric;
            currentSeries.chartType = gUtils.getStudyChartType(currentSeries.studyType, currentSeries.studySeqId);
            self.addSeries([currentSeries]);
        }
        if (currentSeries.paneId > 1) {
            let newPaneName = formationUtil.getFormattedPaneName(currentSeries.entity, currentSeries.studyType, currentSeries.studyPeriod);
            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === currentSeries.paneId;
            });
            currentPane.name(newPaneName);
        }
        //update lower bollinger band series color with upper bollinger band series color while editing
        // Bug 2364503: MI Charting - Color is not getting updated for Bollinger band for last series
        // if (currentSeries.studyType === gUtils.StudyType.BB && currentSeries.studySeqId === 2) {
        //     let upperBBSeries = _.find(self.allPanesSeriesArr(),
        //         function (seri: any) {
        //             let upperBBParentId = gUtils.getParentSeriesIdByStudySeriesId(seri.id);
        //             let lowerBBParentId = gUtils.getParentSeriesIdByStudySeriesId(currentSeries.id);
        //             return seri.studyType === gUtils.StudyType.BB && seri.studySeqId === 1 &&
        //                 upperBBParentId === lowerBBParentId;
        //         });
        //     let currPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === currentSeries.paneId);
        //     let currChart = gUtils.findHighchartById(self.view, _.get(currPane, 'chartId'));
        //     if (upperBBSeries) {
        //         gUtils.updateSeriesColor(currentSeries.id, upperBBSeries.color, currChart, currentSeries.paneId);
        //     }
        // }
        // Removed unneccessary lines of code.

        // #EOF
    }

    public onExportChartBuilder(exportType: any) {
        //getSVG will reload the chart and trigger reload of grid, and the export will not work;
        self.preventReload(true);
        self.chartExportType(exportType);
        let chartSVG = self.getChartSVGs();
        self.preventReload(false);
        let allsvgs = self.getMultiPaneSVGs();
        //Bug 2492940: MI-Charting:- Y axis scale is not displaying for OBV in report builder
        self.updateYAxisGridLines(MIChartBuilderCommon.chartBuilderCommonObject.chartBuilderInstance.panes()[0].settings().gridLinesEnabled(), true);
        if (self.chartExportPromise) {
            return q.when(self.chartExportPromise()).then(function (generateImage: any) {
                return generateImage(chartSVG).then(function () {
                    return self.doExport(exportType, allsvgs);
                });
            });
        } else {
            return "";
        }
    }

    public dataload() {
        if (self.isReportBuilder) {
            self.dataloadComplete.resolve(q.when(self.onExportChartBuilder(shellViewModel.rbExportType)).then(function (func) {
                return {
                    exportOptionsFunc: func
                };
            }));
        } else {
            self.dataloadComplete.resolve();
        }
    }

    public onPlottedDatesChanged(start: string, end: string) {
        var plottedDateRange = self.chartBuilderInstance.plottedDateRange;

        if (plottedDateRange().start !== null && plottedDateRange().end !== null) {
            if (plottedDateRange().start !== start || plottedDateRange().end !== end) {
                plottedDateRange({
                    start: start,
                    end: end
                });
            }
        }
    }

    public getSeriesId() {
        var newSeriesId = self.seriesIdCounter + 1;
        self.seriesIdCounter++;
        return newSeriesId;
    }

    public getPaneId() {
        self.paneCounter++;
        return self.paneCounter;
    }

    public getYAxes(paneId: number = 1): Array<CBModels.Yaxis> {
        let pane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
            return pane.id === paneId;
        });
        return pane.yAxisCollection();
        //return self.chartBuilderInstance.panes()[0].yAxisCollection();
    }

    public chartChangedCB(paneId: number = 1) {
        self.yAxes(self.getYAxes(paneId));
        self.adjustTitleOrSubTitleorLegendPositions(undefined, undefined, undefined, undefined, false, paneId);
        //This is a callback to set global settings font data on series modification
        self.chartBuilderInstance.seriesUpdatedCallBack();
    }

    public loadKeyDevsCB(inSeries: any[]) {
        var series = _.filter(inSeries, (siri: any) => {
            return _.get(siri, 'annotations.length', 0) > 0 ||
                _.get(siri, 'customAnnotations.length', 0) > 0;
        });


        if (series.length > 0) {
            self.selectedKeydevOpts([]);
            var seriesIds = series.map((x: any) => x.id);
            self.selectedKeyDevSeriesIds(seriesIds);

            //Set Selected values for KeydevOpts -- Load Chart
            _.forEach(series, (siri: any) => {
                if (!_.contains(self.selectedKeydevOpts(), 1) && siri.keyDevOptions && siri.keyDevOptions.subsideries) {
                    self.selectedKeydevOpts.push(1);
                }
                if (!_.contains(self.selectedKeydevOpts(), 2) && siri.keyDevOptions && siri.keyDevOptions.investments) {
                    self.selectedKeydevOpts.push(2);
                }

            });
            //End
            var customKeyDevs: any = {};
            var removedKeyDevs: any = {};

            _.forEach(series, (siri: any) => {
                if (_.get(siri, 'customAnnotations.length', 0) > 0) {
                    customKeyDevs[siri.id] = siri.customAnnotations;
                }
                if (_.get(siri, 'removedAnnotations.length', 0) > 0) {
                    removedKeyDevs[siri.id] = siri.removedAnnotations;
                }
            });

            self.customKeyDevs(customKeyDevs);
            self.removedKeyDevs(removedKeyDevs);

            var keyDevNodeIds = series[0].annotations;

            var dateRange = self.chartBuilderInstance.chartDateRange();

            self.updateKeyDevs(keyDevNodeIds, series, dateRange, true, false);
            //self.selectedKeyDevTypeIds(keyDevNodeIds);

        }
    }

    public updateKeyDevs(nodes: any[], series: any[],
        dateRange: any, redraw: boolean, timeFrameKeydevs = false) {
        //var chartContainer = $('.chart-area-container');

        // var checkval = 0;

        var keyDevTypeIds = nodes.filter((x: string) => {
            return _.startsWith(x, "type") || x === "cat:custom";
        }).map((x: string) => {
            var type = x.split(':')[1];
            return type === "custom" ? "custom" :
                type ? parseInt(type) :
                    -1;
        });

        var types = anntUtil.getSelectedKeyDevIds(keyDevTypeIds,
            self.keyDevTypes());
        var typeNodeIds = self.selectedKeyDevTypeIds().filter((x: string) => {
            return _.startsWith(x, "type") || x === 'cat:custom';
        });

        gUtils.blockChart(true);
        anntUtil.getKeyDevs(types, series, dateRange).then(
            (keyDevs) => {
                var chart = gUtils.findHighchartById(self.view,
                    _.get(self.firstPane(), 'chartId'));

                if (self.selectedKeyDevTypeIds() && self.selectedKeyDevTypeIds().length > 0) {
                    var selKeyDevArray: any = _.map(self.selectedKeyDevTypeIds(), function (it: any) {
                        var idString = it.split(":")[1];
                        return idString === "custom" ? "custom" : parseInt(idString);
                    });

                    for (var key in keyDevs) {
                        if (keyDevs.hasOwnProperty(key)) {
                            keyDevs[key] = _.filter(keyDevs[key], function (ie: any) {
                                return selKeyDevArray.contains(ie.type.id);
                            });
                        }
                    }
                }


                self.keyDevs(keyDevs);

                var allKeyDevs = anntUtil.createSiriKeyDevs(series,
                    keyDevs, self.customKeyDevs(), self.removedKeyDevs());
                anntUtil.updateSeriesAnnotations(chart, series, allKeyDevs);
                if (redraw) {
                    chart.redraw(false);
                }
                // #added New logic only for showing toaster message if no key devs plotted ** I need to change logic if I found better solution***
                // added because Resolver calling 2 Times for each series *****
                if (timeFrameKeydevs) {//  validating if no key devs available for given series on particular timeframe.
                    if (series.length === 1) {
                        _.each(series, (siri) => {
                            if (_.isEmpty(self.validatingNokeyDevs())) {
                                self.validatingNokeyDevs.push(siri.entity.companySnlKeyInstn);// added new self observable array***
                                anntUtil.handleNoDataMessage([], typeNodeIds, keyDevs, siri, true);

                            } else {
                                if (self.validatingNokeyDevs().indexOf(siri.entity.companySnlKeyInstn) !== -1) {
                                    self.validatingNokeyDevs().length = 0;
                                }
                                // }
                            }
                        });
                    } else {// Handling if multiple series are plotted ** validating Keydevs for multiple Series
                        _.each(series, (siri) => {
                            if (self.validatingNokeyDevs().indexOf(siri.entity.companySnlKeyInstn) === -1) {
                                self.validatingNokeyDevs.push(siri.entity.companySnlKeyInstn);
                                anntUtil.handleNoDataMessage([], typeNodeIds, keyDevs, siri, true);
                            } else {
                                let seriesIndex = _.findIndex(self.validatingNokeyDevs(), function (seriesId: any) { return seriesId === siri.entity.companySnlKeyInstn; });
                                self.validatingNokeyDevs.splice(seriesIndex, 1);
                            }
                        });
                    }
                }
                // # EOF Region
            }
        ).fin(() => {
            gUtils.blockChart(false);
            var partials = self.forcedPartials();
            _.map(series, function (seri: any) {
                _.map(seri.removedAnnotations, function (item: any) {
                    if (!_.contains(self.forcedPartials(), `type:${item.type.id}`)) {
                        partials.push(`type:${item.type.id}`);
                    }

                    if (!_.contains(self.forcedPartials(), `cat:${item.type.category.id}`)) {
                        partials.push(`cat:${item.type.category.id}`);
                    }
                });

                if (seri.pinnedAnnotations && seri.pinnedAnnotations.length > 0) {
                    _.each(seri.pinnedAnnotations, function (ele: any) {
                        //var pinedbxox = decodeURIComponent(unescape(ele));
                        //chartContainer[0].appendChild(ele);
                        let point = {
                            x: ele.keyDevDate,
                            seriesId: seri.id,
                            id: ele.isSideBar ? ele.keyDevText[0].id : seri.id
                        };
                        let currentDate = new Date(ele.keyDevDate);
                        let formattedkeyDevText = anntUtil.formatKeyDevs(ele.keyDevText, currentDate, securityClient, seri.id, true);
                        pinnAnnt.drawPinnAnnotation(point, formattedkeyDevText, ele.width, ele.height, ele.left, ele.top, ele.isSideBar);
                    });
                }


            });
            if (partials.length > 0) {
                self.forcedPartials(partials);
            } else {
                self.forcedPartials([]);

            }
            self.selectedKeyDevTypeIds(nodes);
            self.miTreeSetSelectedValue(true);

        });
    }

    public updateYAxisCB(e: any) {
        var yAxis = gUtils.getHighchartYAxis(e.yAxisId, self.sidebarSelectedPaneId());
        var miYAxis = gUtils.getChartBuilderYAxis(e.yAxisId, self.getYAxes(self.sidebarSelectedPaneId()));

        if (!yAxis) {
            return;
        }

        var paneSeries = self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1].seriesCollection;

        if (e.type === "scaleChange") {
            var isCustom = e.data.type === "custom";

            var min = isCustom ? e.data.min : yAxisUtil.getYAxisDefaultExtremes(yAxis).min;
            var max = isCustom ? e.data.max : yAxisUtil.getYAxisDefaultExtremes(yAxis).max;

            var scaleObj = {
                type: e.data.type,
                min: min,
                max: max
            };
            yAxis.userOptions.scale = scaleObj;
            miYAxis.scale = scaleObj;

            yAxisUtil.updateYAxisExtremes(true, yAxis, self.getYAxes(self.sidebarSelectedPaneId()),
                min, max,
                isCustom, isCustom);

            var flagSeries = _.where(yAxis.chart.series, { type: 'flags' });
            if (flagSeries && flagSeries.length > 0) {
                anntUtil.setAnnotationMarkerGroup(yAxis.chart);
            }

        } else if (e.type === "valueScaleChange") {
            var valueScaleObj = {
                type: e.data.type,
                indexTo: e.data.indexTo,
                indexDate: e.data.indexDate
            };

            yAxis.userOptions.valueScale = valueScaleObj;
            miYAxis.valueScale = valueScaleObj;

            if (valueScaleObj.type === "relative") {
                gUtils.moveTotalReturnToPercentageAxis(self.view, self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1], miYAxis);
                yAxisUtil.removeYAxisHack();
            }

            if (valueScaleObj.type === "absolute") {
                yAxisUtil.moveTotalReturntoNewAxis(self.view, self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1], miYAxis);
                yAxisUtil.removeYAxisHack();
            }

            if (paneSeries.valueHasMutated) {
                paneSeries.valueHasMutated();
            }
        }
        else if (e.type === "numberFormatChange") {
            var numberFormatObj = {
                type: e.data.type,
                format: e.data.format
            };

            yAxis.userOptions.numberFormat = numberFormatObj;
            miYAxis.numberFormat = numberFormatObj;

            if (paneSeries.valueHasMutated) {
                paneSeries.valueHasMutated();
            }
        }
        else if (e.type === "decimalValueChange") {

            yAxis.userOptions.decimalPoints = e.data.value;
            miYAxis.decimalPoints = e.data.value;

            if (paneSeries.valueHasMutated) {
                paneSeries.valueHasMutated();
            }
        }
        else if (e.type === "negativeFormatChange") {

            var negativeFormatObj = {
                type: e.data.type,
                format: e.data.format
            };

            yAxis.userOptions.negativeFormat = negativeFormatObj;
            miYAxis.negativeFormat = negativeFormatObj;

            if (paneSeries.valueHasMutated) {
                paneSeries.valueHasMutated();
            }
        }

        self.yAxes(self.getYAxes(self.sidebarSelectedPaneId()));
    }

    public onDatesChanged(start: string, end: string,
        prevSel: CBModels.ButtonI, currSel: CBModels.ButtonI,
        datesChangedByButton: boolean, isInvokedFromDefaultState?: boolean) {

        self.globalPos.currTimePos = currSel;
        self.globalPos.prevTimePos = prevSel;

        var formattedStart = start.substring(6, 10) + start.substring(0, 2) + start.substring(3, 5);
        var formattedEnd = end.substring(6, 10) + end.substring(0, 2) + end.substring(3, 5);

        var chartDateRange = self.chartBuilderInstance.chartDateRange;

        if (chartDateRange().start !== null && chartDateRange().end !== null) {

            //This method basically clears all the data labels from each series on highchart
            //Reason why method is invoking from this place is. High chart retains the Data labels when the time frame is changed
            //As per the Ac of the Datalabels story, All labels can be enabled for series if the time frame is less than or equals to 6 Months by considering performance in mind
            //use Case: If the user enables all the labels for a series when the time frame is selected as 6 months
            //            and changes the time frame to 10 years then highchart is retaining the datalable,
            //           It is taking long time to enable the datalabels for 10 Years and getting memory exceptions.
            // To overcome the above use case we are disabling the datalabels before timeframe is changed
            gUtils.disableDatalabels();

            if (chartDateRange().start !== formattedStart || chartDateRange().end !== formattedEnd) {
                //chartDateRange needs to be set based on the selected time controls
                if (datesChangedByButton) {
                    chartDateRange({
                        start: formattedStart,
                        end: formattedEnd,
                        isStaticTimeFrameEnabled: true,
                        staticTimeFrameText: self.globalPos.currTimePos.text,
                        staticTimeFrameValue: self.globalPos.currTimePos.value
                    });
                } else {
                    chartDateRange({
                        start: formattedStart,
                        end: formattedEnd,
                        isStaticTimeFrameEnabled: false,
                        staticTimeFrameText: "",
                        staticTimeFrameValue: 0
                    });
                }
                self.onPlottedDatesChanged(formattedStart, formattedEnd);
                if (gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()).length > 0) {
                    self.updateSeriesFromTimeFrame(datesChangedByButton, undefined, true, [], true, true);
                }
            }
        }
        else {
            chartDateRange({
                start: formattedStart,
                end: formattedEnd,
                isStaticTimeFrameEnabled: false,
                staticTimeFrameText: "",
                staticTimeFrameValue: 0
            });
        }

        self.selectedButtonFromTimeFrame(intraday.getDateDifference(formattedStart, formattedEnd));
        if ((currSel) && (currSel.text)) {
            chartDateRange().isStaticTimeFrameEnabled = datesChangedByButton;
            if (isInvokedFromDefaultState) {
                chartDateRange().isStaticTimeFrameEnabled = isInvokedFromDefaultState;
            }
            chartDateRange().staticTimeFrameText = currSel.text;
            chartDateRange().staticTimeFrameValue = currSel.value;
        }
    }

    public changeGlobalRelativity(relativity: CBModels.Relativity) {
        //      var relativityE = relativity === 'abs' ? CBModels.Relativity.Absolute :
        //                        relativity === 'rel' ? CBModels.Relativity.Relative :
        //                        CBModels.Relativity.None;
        self.globalRelativity(relativity);
        _.each(self.chartBuilderInstance.panes(), (pane: any) => {
            if (!pane.isChildPane) {
                self.updateYAxesRelativity(relativity, pane);
            }
        });
    }

    public updateYAxesRelativity(rel: CBModels.Relativity, pane: CBModels.Pane) {
        var yAxes = gUtils.getHighchartYAxes(pane.id);
        var newValue;

        _.forEach(yAxes, (yAxis: any) => {
            var miYAxis = gUtils.getChartBuilderYAxis(yAxis.userOptions.id,
                self.getYAxes(pane.id));
            if (yAxisUtil.isRelativeCapableYAxis(miYAxis, pane.seriesCollection())) {
                if (yAxis.userOptions.valueScale) {
                    newValue = rel === CBModels.Relativity.Absolute ? 'absolute' :
                        rel === CBModels.Relativity.Relative ? 'relative' :
                            yAxis.userOptions.valueScale.type;

                    yAxis.userOptions.valueScale.type = newValue;
                    miYAxis.valueScale.type = newValue;
                } else {
                    newValue = rel === CBModels.Relativity.Absolute ? 'absolute' :
                        rel === CBModels.Relativity.Relative ? 'relative' :
                            'default';

                    yAxis.userOptions.valueScale = {
                        type: newValue
                    };
                    miYAxis.valueScale.type = newValue;
                }
            }
        });

        var paneSeries = pane.seriesCollection;
        if (paneSeries.valueHasMutated) {
            paneSeries.valueHasMutated();
        }

        self.yAxes(self.getYAxes(pane.id));
    }

    public resetChartBuilderViewModel(resetType: string = "") {
        self.isLoadChart = resetType === ResetChartBuilder.ResetType.LoadChart ? true : false;
        var emptyArray: any = [];
        $('.highcharts-button').hide();
        MIChartBuilderCommon.chartBuilderCommonObject.updateSeriesCol(emptyArray);
        self.entitySelectedValue([]);
        self.metricsSelectedValues([]);
        self.chartBuilderInstance.entities.removeAll();
        self.chartBuilderInstance.metrics.removeAll();
        self.firstPaneSeriesArr.notifySubscribers(self.firstPaneSeriesArr());
        self.allPanesSeriesArr.notifySubscribers(self.allPanesSeriesArr());
        pinnAnnt.removeAllPinnAnnt();

        if (ko.utils.unwrapObservable(self.actualData)) {
            self.actualData.removeAll();
        }
        if (ko.utils.unwrapObservable(self.yAxes)) {
            self.yAxes.removeAll();
        }

        var allUISeries = gUtils.getAllUISeries();
        if ((allUISeries) && (allUISeries.length > 0)) {
            self.removeSeries(allUISeries, false, false);
        }

        self.isChartDataReadyToInsert(false);

        self.isAnnotationsDataReadyToInsert(false);

        if (common.isOffice && chartDataModel) {
            chartDataModel.resetCache();

            //Reset to defaults
            var subTitleFont = gUtils.getDefaultFontSettings(gUtils.settingsType.subTitleSettings),
                titleFont = gUtils.getDefaultFontSettings(gUtils.settingsType.titleSettings),
                xAxisFont = gUtils.getDefaultFontSettings(gUtils.settingsType.xAxisSettings),
                legendNameFont = gUtils.getDefaultFontSettings(gUtils.settingsType.legendSettings),
                xAxisLabelFont = gUtils.getDefaultFontSettings(gUtils.settingsType.xAxisLabelFontSettings);
            for (var i = 0; i < self.chartBuilderInstance.panes().length; i++) {
                self.chartBuilderInstance.panes()[i].settings().titleFontSettings(titleFont);
                self.chartBuilderInstance.panes()[i].settings().subTitleFontSettings(subTitleFont);
                self.chartBuilderInstance.panes()[i].settings().xAxisFontSettings(xAxisFont);
                self.chartBuilderInstance.panes()[i].settings().legendFontSettings(legendNameFont);
                self.chartBuilderInstance.panes()[i].settings().xAxisLabelFontSettings(xAxisLabelFont);
                self.chartBuilderInstance.panes()[i].settings().gridLinesEnabled(true);
                self.updateHighchartLabels(self.chartBuilderInstance.panes()[i]);
            }

        }
    }

    public findKeyDevSiriFromChart(chart: any, siriId: number) {
        return _.find(chart.series, (x: any) => {
            return x.type === "flags" && x.userOptions.onSeries === siriId;
        });
    }

    public getChartBuilderData() {
        var chartData = ko.toJS(self.chartBuilderInstance);
        //Adding all the Key Devs
        var kDSeriesIds = self.selectedKeyDevSeriesIds();
        //var selectedKDTypes = self.selectedKeyDevTypeIds();
        var customKDs = self.customKeyDevs();
        var removedKDs = self.removedKeyDevs();

        _.forEach(chartData.panes, (pane: any) => {
            _.forEach(pane.seriesCollection, (siri: any) => {
                delete siri.orignalData;
                delete siri.ohlsData;
                var siriId = siri.id;
                if (_.some(kDSeriesIds, (id: any) => id === siriId)) {
                    //siri.annotations = selectedKDTypes;
                    siri.annotations = siri.annotations;
                    //siri.customAnnotations = _.filter(customKDs[siriId],
                    //    (x: any) => x.isTransient);
                    if (_.contains(siri.annotations, "cat:custom")) {
                        siri.customAnnotations = _.filter(customKDs[siriId],
                            (x: any) => x.isTransient);
                    } else {
                        siri.customAnnotations = customKDs[siriId];
                    }

                    siri.removedAnnotations = removedKDs[siriId];
                    pinnAnnt.updatePinnedCordinates(siri);
                }
            });
        });
        chartData.metrics = gUtils.formatMetrics(chartData.metrics);

        if (_.get(chartData, 'panes[0].settings')) {
            chartData.panes[0].settings.globalRelativity = self.globalRelativity();
        }

        return chartData;
    }

    public pushSeriesInOfficeRefresh(series: any) {
        var existingIds = _.map(self.inProgressSeries(), function (obj: any) {
            return obj.id;
        });
        if (!_.contains(existingIds, series.id)) {
            self.inProgressSeries.push({ id: series.id });
        }
    }

    public removeSeriesInOfficeRefresh(series: any) {
        if (series && series.userOptions) {
            logOfficeMessages("Chart rendered");
            if (self.isOfficeRefreshMode()) {
                var removableSeries = _.find(self.resetSeriesCollection(), function (obj: any) {
                    return obj.id === series.userOptions.id;
                });
                if (removableSeries) {
                    self.resetSeriesCollection.remove(removableSeries);
                }
            }
            var removableObject = _.find(self.inProgressSeries(), function (obj: any) {
                return obj.id === series.userOptions.id;
            });
            if (removableObject) {
                self.inProgressSeries.remove(removableObject);
                if (self.inProgressSeries().length === 0) {
                    if (common.isOffice) {
                        if (!self.isOfficeRefreshMode()) {
                            logOfficeMessages("All series rendered for insert button enable");
                            self.isChartDataReadyToInsert(true);
                        }
                        else {
                            logOfficeMessages("All series rendered for update button enable");
                            if (self.resetSeriesCollection().length === 0) {
                                self.isChartDataReadyToInsert(true);
                            }
                        }
                    }
                }
            }
        }
    }

    public updateSingleChartYAxisGridlines(paneId: number, isGridLines: boolean, isRedraw: boolean = false) {
        let currChart = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[paneId - 1], 'chartId'));
        if (currChart) {
            _.each(currChart.yAxis, function (yAxis: any) {
                yAxis.update({
                    gridLineWidth: isGridLines ? 1 : 0,
                    minorGridLineWidth: isGridLines ? 1 : 0
                }, false);
            });
            if (isRedraw) {
                currChart.redraw();
            }
            self.chartBuilderInstance.panes()[paneId - 1].settings().gridLinesEnabled(isGridLines);
        }
    }

    public activate(settings: any) {
        $.extend(self, _.defaults(_.pick(settings, 'keyPage', 'tools', 'entityPlaceHolderCaption'), {
            keyPage: 364852,
            tools: {},
            entityPlaceHolderCaption: webStrings.chartBuilderSearchEntityWatermark()
        }));


        logOfficeMessages("Activate start");
        //Adding the platts swtch based on the keypage from PlattsCDN
        self.isPlattsEnabled = self.keyPage === 470818;
        //Apply existing SOC entitlements for GS users

        var allowSaveOpen = !_.contains(securityClient.userProfile().OnlineConfigurations, 4);
        var allowShare = securityClient.userProfile().SharingIsEnabled;
        self.isGSUser = !_.contains(securityClient.userProfile().OnlineConfigurations, 4);
        self.usage = {
            keyForeignLanguage: 0
        };

        // Hiding footer,header And Side bar when chart builder is loaded in Excel.
        // populate the quick sidebar
        if (!common.isOffice) {
            shellViewModel.header.visible(true);
            shellViewModel.footer.visible(true);
            shellViewModel.sidebar.visible(true);

            if (shellViewModel.subHeader.pageTitleContent && shellViewModel.subHeader.pageTitleContent.companyCeasedMessage) {
                shellViewModel.subHeader.pageTitleContent.companyCeasedMessage = '';
            }
        }

        MIChartBuilderCommon.chartBuilderCommonObject.GlobalSettings = { currencySymbol: '$', KeyCurrency: null };

        MIChartBuilderCommon.chartBuilderCommonObject.chartLoadComplete = function () {
            if (!self.isGetChartSVGCalled()) {
                for (var i = 0; i < self.chartBuilderInstance.panes().length; i++) {
                    self.updateHighchartLabels(self.chartBuilderInstance.panes()[i], true);
                }
            }
        };

        function getCurrencyInformation() {
            var userProf = securityClient.userProfile();
            MIChartBuilderCommon.chartBuilderCommonObject.GlobalSettings.KeyCurrency = userProf.KeyCurrency;
            if (MIChartBuilderCommon.chartBuilderCommonObject.GlobalSettings.KeyCurrency !== null) {
                var getcurrencyInfoUri = 'LookupCurrencys?$select=CurrencySymbol,KeyCurrency&$filter=(KeyCurrency + eq +' + "'" + userProf.KeyCurrency + "'" + ')&cache=900';
                var url = common.config.uris.data.api.v2.companies + '/' + getcurrencyInfoUri;

                var dataPromise: any = modelUtilities.getODataAPIRequest(url);
                return dataPromise.then(function (data: any) {
                    if (data && data.value && data.value.length > 0) {
                        _.each(data.value, function (currencyInfo: any) {
                            MIChartBuilderCommon.chartBuilderCommonObject.GlobalSettings.currencySymbol = currencyInfo.CurrencySymbol;
                        });
                    }
                });
            }
        }
        getCurrencyInformation();

        // Export Functionality
        // get the zone for this view
        self.offlineExport = function () {
            self.chartExportType(exportUtil.enums.format.excel);
            return zone.root.execute(
                function () {
                    let chartSVG = self.getMultiPaneSVGs();
                    self.preventReload(false);
                    self.updateYAxisGridLines(MIChartBuilderCommon.chartBuilderCommonObject.chartBuilderInstance.panes()[0].settings().gridLinesEnabled(), true);
                    if (self.chartExportPromise) {
                        for (let i = 0; i < chartSVG.length; i++) {
                            q.when(self.chartExportPromise()).then(function (generateImage: any) {
                                generateImage(chartSVG[i]).then(function () {
                                    var todaySDate = new Date();
                                    var downloadDate = new Date(todaySDate.getUTCFullYear(), todaySDate.getUTCMonth(), todaySDate.getUTCDate()); // get around time zone issue
                                    var formattedDate = localizationUtility.format(downloadDate, "SHORT", common.culture());
                                    var formattedTime = moment().format(' h:mm:ss a');
                                    var fileName = 'Chart_' + formattedDate + formattedTime;
                                    var imageName = self.chartExportSchema().rows.reporttablerow[0].cells.reporttablecell[exportUtil.constants.cell.content];
                                    var filePath = common.config.uris.data.export.v2 + 'Retrieve?filename=' + imageName + '&exportFileName=' + fileName;
                                    window.open(filePath);
                                });

                            });
                        }
                    }
                }
            );

        };

        self.excelExport = function () {
            return zone.root.execute(
                function () {
                    if (self.onExportChartBuilder) {
                        self.onExportChartBuilder(exportUtil.enums.format.excel);
                    }
                }
            );
        };

        self.pdfExport = function () {
            return zone.root.execute(
                function () {
                    if (self.onExportChartBuilder) {
                        self.onExportChartBuilder(exportUtil.enums.format.pdf);
                    }
                }
            );
        };

        self.htmlExport = function () {
            return zone.root.execute(
                function () {
                    if (self.onExportChartBuilder) {
                        self.onExportChartBuilder(exportUtil.enums.format.html);
                    }
                }
            );
        };

        self.wordExport = function () {
            return zone.root.execute(
                function () {
                    if (self.onExportChartBuilder) {
                        self.onExportChartBuilder(exportUtil.enums.format.word);
                    }
                }
            );
        };

        self.createQuickAlert = function () {
            return zone.root.execute({
                execute: function () {
                    var basePageDetails = {
                        companyBriefing: {
                            keyInstn: self.title.keyInstn,
                            instnName: self.title.desc,
                            contentType: 'Stock',
                            keyPage: 436176
                        }
                    };
                    ViewUtilities.launchCreateQuickAlertDialog(basePageDetails);
                },
                message: webStrings.processingCaption()
            });
        };

        self.saveChartButtonText = ko.observable(webStrings.save());
        var groups = {
            saveChart: {
                css: 'fa fa-sign-out', name: self.saveChartButtonText, id: 7
            },
            exportGroup: {
                css: 'fa fa-sign-out', name: webStrings.compactHeaderExport(), id: 1
            }
        };

        //Save Chart : need to shift this code

        self.openSavedChartbuilderInstance = function () {
            var settings = {
                mode: "load",
                getChartBuilderData: self.getChartBuilderData,
                keyDevTypes: self.keyDevTypes
            };
            dialog.show(new SaveAndLoadDialogViewModel(), settings).then(function (chartBuilderData: any) {
                if (chartBuilderData) {
                    self.keyOnlineSharedItem = "00000000-0000-0000-0000-000000000000";
                    self.sharedItemAccessLevel = "";
                    self.onlineSharedItemShareable = true;
                    self.saveChartButtonText(webStrings.save());
                    self.plotSavedChart(chartBuilderData);

                    let sharing: any = common.config.uris.security.sharing;

                    let getSharedItemWithMeUrl = sharing.GetSharedItemWithMe + "?oid=" + chartBuilderData.selectedSavedChart.Key.split("_")[1];

                    ajaxUtilities.ajaxRequest({
                        url: getSharedItemWithMeUrl,
                        type: "GET"
                    }).then(function (data) {

                        if (data !== "No Data Found") {

                            self.keyOnlineSharedItem = data.KeyOnlineSharedItem;
                            self.sharedItemAccessLevel = data.AccessLevel;
                            self.onlineSharedItemShareable = data.OnlineSharedItemShareable;
                            if (self.sharedItemAccessLevel === "View") {
                                self.saveChartButtonText("Save As");
                            }
                        }

                    });
                }

            });
        };

        self.loadsavedChart = function (chartid: any) {
            chartBuilderDataStorageModel.getSavedChartMetaData(chartid).then(function (savedChartMetaData) {
                var panes = JSON.parse(savedChartMetaData.Panes);


                _.forEach(panes, function (pane: any) {
                    _.forEach(pane.seriesCollection, function (series: any) {

                        var annotations = series.annotations;

                        var isNew = _.some(annotations, (ann: any) => {
                            var annStr = "" + ann;
                            return _.startsWith(annStr, 'type') || _.startsWith(annStr, 'cat');
                        });

                        series.annotations = _.map(annotations, (anno: CBModels.KeyDevId) => {
                            var typeId = anno;
                            return isNew ? typeId :
                                typeId === 160 ? "type:custom" :
                                    "type:" + anntUtil.retrieveNodeIdFromTypeId(typeId, self.keyDevTypes());
                        });

                    });

                });

                let chartBuilderData = {
                    entities: JSON.parse(savedChartMetaData.Entities),
                    metrics: JSON.parse(savedChartMetaData.Metrics),
                    panes: panes,
                    chartDateRange: JSON.parse(savedChartMetaData.Timeframe),
                    selectedSavedChart: { Name: savedChartMetaData.Name, Key: savedChartMetaData.Key },
                    globalSettings: _.get(panes[0], 'settings.globalRelativity')
                };

                self.plotSavedChart(chartBuilderData);
            });

        };
        self.plotSavedChart = function (chartBuilderData: any) {
            self.selectedSavedChart = chartBuilderData.selectedSavedChart;
            if (!self.isStockChart()) {
                shellViewModel.subHeader.pageTitleContent.viewModel().title.subtitle(self.selectedSavedChart.Name);
            }
            let listIds = _.map(_.filter(chartBuilderData.entities, function (eachItem: any) { return eachItem.contentSet === 10; }), 'id');
            if (listIds && listIds.length > 0) {//this code is to check for any deleted saved list , if yes removing from the object and showing a toast message.
                let counter = 0;
                _.forEach(listIds, function (eachListId: string) {
                    listIds[counter] = eachListId.replace('lists', 'ScreenerSet');
                    counter++;
                });
                gUtils.blockChart(true);
                q.allSettled(chartDataModel.allListsCheck(listIds)).then(function (results) {
                    gUtils.blockChart(false);
                    if ((_.filter(results, function (item: any) { return item.state === 'rejected'; })).length > 0) {
                        //all list Ids in the saved data
                        let allLists = _.map(_.filter(chartBuilderData.entities, function (eachItem: any) { return eachItem.contentSet === 10; }), 'id');
                        let aliveLists = _.map(_.map(results.filter(x => x.state !== 'rejected'), 'value.Key'), function (item: string) { return 'lists_' + item.replace('ScreenerSet_', '').toUpperCase(); });
                        let deletedLists = _.filter(allLists, function (eachItem: any) { return aliveLists.indexOf(eachItem) < 0; });
                        self.removeDeletedLitsAndPlot(chartBuilderData, deletedLists);
                    } else {
                        self.finalActionForOpenSaved(chartBuilderData);
                    }
                });
            } else {
                self.finalActionForOpenSaved(chartBuilderData);
            }
        };
        self.showShareDialog = function () {

            if (!self.onlineSharedItemShareable) {
                zone.root.notify({
                    message: "You do not have permission to share the chart.",
                    type: "error",
                    dismiss: true
                });
            }

            else {

                if (self.selectedSavedChart) {
                    app.trigger(eventConstants.sharingBox.modalPopup, {
                        modalDialogTitle: 'Share Chart',
                        modalDialogListName: self.selectedSavedChart.Name,
                        locked: self.locked,
                        onlineSharedItem: self.selectedSavedChart.Name,
                        keyOnlineSharedItem: self.keyOnlineSharedItem,
                        keyOnlineSharingCategory: 10,
                        OID: self.selectedSavedChart.Key.split("_")[1],
                        sourceObjectType: 'ChartBuilder',
                        getSharedItems: true,
                        chartInfoBoxMessage: "Sharing will save the chart in its current state",
                        callback: function () {
                            var saveChartBuilderRequestObject = {
                                Key: self.selectedSavedChart.Key,
                                Name: _.trim(self.selectedSavedChart.Name),
                                KeyPerspective: "266637",
                                chartBuilderData: self.getChartBuilderData(),
                                KeyOnlineUserOwner: securityClient.userId()
                            };

                            chartBuilderDataStorageModel.saveChart(saveChartBuilderRequestObject).then(function (response) {

                                self.preservedSavedChartName(saveChartBuilderRequestObject.Name);
                                self.isSavingAChart = false;
                                dialog.close(self, response);

                            });

                        }
                    });
                }
                else {
                    if (self.allPanesSeriesArr().length > 0) {
                        self.showShareDialogNext = true;
                        self.saveChartbuilderInstance();
                    }

                }
            }
        };
        self.removeDeletedLitsAndPlot = function (chartBuilderData: any, deletedLists: string[]) {
            self.deletedListInfo = [];
            //show deleted message
            for (let deletedListId of deletedLists) {
                self.deletedListInfo.push(chartBuilderData.entities.find((x: any) => x.id === deletedListId).companyShortName);
            }
            //filtering entities
            chartBuilderData.entities = chartBuilderData.entities.filter((x: any) => deletedLists.indexOf(x.id) === -1);
            let counter = 0;
            //filtering series list
            for (let pane of chartBuilderData.panes) {
                chartBuilderData.panes[counter].seriesCollection = pane.seriesCollection.filter((x: any) => deletedLists.indexOf(x.entity.id) === -1);
                counter++;
            }
            //plot the chart
            self.finalActionForOpenSaved(chartBuilderData);
        };
        self.finalActionForOpenSaved = function (filteredChartBuilderData: any) {
            if (common.isOffice && _.filter(filteredChartBuilderData.panes, (pane: any) => !pane.isChildPane).length > 1) {
                zone.root.notify({
                    message: webStrings.chartBuilderMultiPaneNotSupportedInOfficeWarningMessage(),
                    type: "warning",
                    dismiss: true
                });
            }
            else {
                self.modifyLoadChartDataForSingleUsedMetrics(filteredChartBuilderData);
                ResetChartBuilder.resetChartBuilder(filteredChartBuilderData, ResetChartBuilder.ResetType.LoadChart, self);
                self.disableAutoOpen = true;
            }
        };
        self.modifyLoadChartDataForSingleUsedMetrics = function (chartData: any) {
            /*if metrics contains volume then=>
            1.remove duplicate volumes and corresponding series
            2.remove multiple volume series
            3.update volume metric property singleSelectableMetricUsed
            */
            let volumeMetrics = _.filter(chartData.metrics, (x: any) => gUtils.isEquivalancyVolumeMetric(x.key));
            if (volumeMetrics.length > 0) {
                //removing duplicate volumes and corresponding series
                if (volumeMetrics.length > 1) {
                    let volumeMetricUUIDs = _.pluck(volumeMetrics, 'uUID').splice(1);//keeping the first volume metric as is
                    _.remove(chartData.metrics, (x: any) => _.includes(volumeMetricUUIDs, x.uUID));
                    _.remove(chartData.panes[0].seriesCollection, (x: any) => _.includes(volumeMetricUUIDs, x.metric.uUID));
                }
                //removing other Volume series except for the first valid entity
                if (_.filter(chartData.entities, (x: any) => !gUtils.isVolumeRestrictedEntity(x.contentSet)).length > 0) {
                    let entityId = _.sortBy(_.filter(chartData.entities, (x: any) => !gUtils.isVolumeRestrictedEntity(x.contentSet)), 'sequenceId')[0].keyUniversalEntity;
                    _.each(chartData.panes, function (eachPane: any) {
                        _.remove(eachPane.seriesCollection, (x: any) => x.entity.keyUniversalEntity !== entityId && gUtils.isEquivalancyVolumeMetric(x.metric.key));
                    });
                    _.remove(chartData.panes[0].seriesCollection, (x: any) => x.entity.keyUniversalEntity !== entityId && gUtils.isEquivalancyVolumeMetric(x.metric.key));
                    //adding the singleSelectableMetricUsed property value to the volume metric in the chartData.metrics object
                    if (_.some(chartData.metrics, (x: any) => gUtils.isEquivalancyVolumeMetric(x.key))) {
                        _.find(chartData.metrics, (x: any) => gUtils.isEquivalancyVolumeMetric(x.key)).singleSelectableMetricUsed = true;
                    }
                }
            }
        };
        self.saveChartbuilderInstance = function () {
            var settings = {
                mode: "save",
                getChartBuilderData: self.getChartBuilderData,
                preservedSavedChartName: self.preservedSavedChartName,
                shouldShowSaveMessage: self.showShareDialogNext,
                showSaveAsOption: (self.sharedItemAccessLevel === "View"),
                chartName: self.selectedSavedChart ? self.selectedSavedChart.Name : ""

            };
            dialog.show(new SaveAndLoadDialogViewModel(), settings).then(function (data) {
                if (data) {
                    self.selectedSavedChart = { Name: data.response.Name, Key: data.response.Key };
                    if (!self.isStockChart()) {
                        shellViewModel.subHeader.pageTitleContent.viewModel().title.subtitle(self.selectedSavedChart.Name);
                    }


                    if (self.sharedItemAccessLevel === "View") {
                        self.keyOnlineSharedItem = "00000000-0000-0000-0000-000000000000";
                        self.sharedItemAccessLevel = "";
                        self.onlineSharedItemShareable = true;
                        self.saveChartButtonText(webStrings.save());
                    }

                    if (self.showShareDialogNext) {

                        self.showShareDialog();
                    }
                }
                self.showShareDialogNext = false;

            });
        };

        self.saveChartTemplate = function () {
            var settings = {
                mode: "save",
                getChartBuilderData: self.getChartBuilderData,
                preservedSavedChartName: self.preservedSavedChartName,
                shouldShowSaveMessage: self.showShareDialogNext,
                showSaveAsOption: (self.sharedItemAccessLevel === "View"),
                chartName: self.selectedSavedChart ? self.selectedSavedChart.Name : "",
                saveTemplate: self.savedTemplates()
            };
            dialog.show(new SaveTemplateViewModel(), settings).then(function (data: any) {
                if (data) {
                    //    self.selectedSavedChart = { Name: data.response.Name, Key: data.response.Key };
                    let filterTemplateString: any = data.response.Name.replace(/chartTemplate_/, '');
                    if (_.where(self.savedTemplates(), { key: data.response.Key, text: filterTemplateString }).length === 0) {
                        self.savedTemplates.push({ key: data.response.Key, text: filterTemplateString });
                    }
                }
            });
        };

        //End
        logOfficeMessages("Activate end");

        if (self.isStockChartModeEnabled || self.isPlattsEnabled) {
            // Save and Open should be allowed for stockChart but should be disabled for Platts
            allowSaveOpen = self.isStockChartModeEnabled && !_.contains(securityClient.userProfile().OnlineConfigurations, 4);

            self.disableAutoOpen = true;
            allowShare = self.isStockChartModeEnabled && !_.contains(securityClient.userProfile().OnlineConfigurations, 4);
            self.isGSUser = self.isStockChartModeEnabled && !_.contains(securityClient.userProfile().OnlineConfigurations, 4);

        }

        var saveChartbuilderInstance: any = { display: allowSaveOpen, order: 8, showOnPage: false, action: self.saveChartbuilderInstance };

        var saveTemplate: any = { display: self.isGSUser, groupId: groups.saveChart.id, order: 9, action: self.saveChartTemplate };
        if (common.isOffice) {
            saveTemplate = { display: self.isGSUser, order: 9, action: self.saveChartTemplate };
        }

        if (!common.isOffice) {
            saveChartbuilderInstance.groupId = groups.saveChart.id;
            saveChartbuilderInstance.group = groups.saveChart;
            saveChartbuilderInstance.showOnPage = true;
        }
        let toolsObject: any = {                                    // To Do => check file Image
            fileimage: {
                display: !common.isOffice,
                groupId: groups.exportGroup.id, order: 2,
                group: groups.exportGroup, showOnPage: true, action: self.offlineExport
            },
            fileexcel: {
                display: !common.isOffice && !self.isPlattsEnabled,
                groupId: groups.exportGroup.id, order: 1,
                group: groups.exportGroup, showOnPage: true, action: self.excelExport
            },
            filepdf: {
                display: !common.isOffice && !self.isPlattsEnabled,
                groupId: groups.exportGroup.id, order: 3,
                group: groups.exportGroup, showOnPage: true, action: self.pdfExport
            },
            fileword: {
                display: !common.isOffice && !self.isPlattsEnabled,
                groupId: groups.exportGroup.id, order: 4,
                group: groups.exportGroup, showOnPage: true, action: self.wordExport
            },
            print: {
                display: !common.isOffice && !self.isPlattsEnabled,
                order: 5, action: self.htmlExport,
                showOnPage: true
            },
            migrateCIQCharts: {
                display: migrateCIQChartsUtil.showMigrateChartOption(self.isPlattsEnabled, self.isStockChartModeEnabled) && allowSaveOpen,
                showOnPage: true, order: 3,
                action: migrateCIQChartsUtil.migrateCIQChart
            },
            share: {
                display: allowShare,
                order: 5, action: self.showShareDialog,
                showOnPage: !common.isOffice && !self.isPlattsEnabled
            },
            openSavedChartbuilderInstance: {
                display: allowSaveOpen,
                order: 6, action: self.openSavedChartbuilderInstance,
                showOnPage: !common.isOffice && !self.isPlattsEnabled
            },
            saveChartbuilderInstance: saveChartbuilderInstance,
            saveReportTemplate: saveTemplate
        };

        let viewUtilitiesActivate: any;
        if (self.isStockChartModeEnabled) {
            toolsObject.createAlert = {
                display: !common.isOffice && !self.isPlattsEnabled,
                order: 0, action: self.createQuickAlert,
                showOnPage: true
            };
        }
        switch (self.keyPage) {
            case 436176: {
                self.isStockChartModeEnabled = true;
                self.tools.tools = {};
                $.extend(true, self.tools, {
                    keyPage: 436176,
                    tools: toolsObject,
                    dataloadComplete: self.dataloadComplete
                });

                viewUtilitiesActivate = ViewUtilities.activate(self.tools);
                break;
            }
            default: {
                let titleObject: any = {
                    desc: webStrings.chartBuilderHeaderTitle()
                };

                viewUtilitiesActivate = ViewUtilities.activate({
                    keyPage: self.keyPage,
                    // keyEntity: null,   // can not pass null
                    usage: self.usage,
                    keyEntityType: menuModel.KeyEntityTypeMarkets,
                    menu: "top",
                    title: titleObject,
                    tools: toolsObject
                });
                break;
            }
        }

        return asyncUtilities.require("models/office/layer.core")
            .then(() => {
                return viewUtilitiesActivate;
            });
    }

    public canActivate() {

        return ViewUtilities.canActivate({
            allowAnonymous: false,
            keyPage: 364852,
            keyEntityType: menuModel.KeyEntityTypeMarkets
        });

    }

    public binding(view: any) {
        self.view = view;

        self.viewContext = new ViewUtilities(view, self);
        var oc = self.viewContext.observable;

        let zoneContext: any = self.viewContext.zone;
        self.zoneContext = zoneContext;

        //Loading the perspectives so they have time to be ready and don't slow things down
        self.perspectiveReady = oc.observable(false);
        self.perspective = oc.observable(null);
        self.marketPricingPerspective = oc.observable(null);
        self.marketPricingPerspectiveReady = oc.observable(false);

        perspective.getPerspective({
            keyPerspective: '266637',
            isHeadless: false
        }).then(function (perspective: any) {
            self.perspective(perspective);
            self.perspectiveReady(true);
        });

        perspective.getPerspective({
            keyPerspective: '254275',
            isHeadless: false
        }).then(function (perspective: any) {
            self.marketPricingPerspective(perspective);
            self.marketPricingPerspectiveReady(true);
        });

        self.chartExportPromise = oc.observable();
        MIChartBuilderCommon.chartBuilderCommonObject.indexDate = oc.observable();
        self.isStockChart = oc.observable(self.isStockChartModeEnabled);
        self.chartExportSchema = oc.observable();
        self.summaryExportSchema = oc.observable();
        self.hiddenSeries = oc.observableArray();
        self.chartExportType = oc.observable(exportUtil.enums.format.excel);
        self.chartControl = oc.observable(null);
        self.preventReload = oc.observable(false);
        self.selectedKeyDevTypeIds = oc.observableArray([]);
        self.selectedKeyDevSeriesIds = oc.observableArray([]);
        self.keyDevs = oc.observableArray([]);
        self.customKeyDevs = oc.observable({});
        self.removedKeyDevs = oc.observable({});
        self.preservedSavedChartName = oc.observable(null);
        self.allPanesSeriesArr = oc.observableArray([]);
        self.resetSeriesCollection = oc.observableArray([]);

        self.selectedCurrFromDD = oc.observable(null);
        self.selectedButtonFromTimeFrame = oc.observable(7);
        self.currencyFromSaveChart = oc.observable();
        self.selectedColorPaletteId = oc.observable(-1);
        self.refreshChartSummary = oc.observable(false);
        self.innerWidth = oc.observable();
        self.isSubTitleAtBottomRight = oc.observable(false);
        self.isReportBuilder = common.isReportBuilder() || common.isReportBuilderPreview();
        self.saveModificationsMessage = webStrings.saveModificationsMessage();
        self.saveModifications = webStrings.saveModifications();
        self.paneImageSchema = oc.observableArray([]);
        self.dateRange = {
            start: oc.observable(),
            end: oc.observable()
        };
        self.selectedKeydevOpts = oc.observableArray();
        self.isChartOnChildPane = oc.observable(false);

        self.hasTotalReturn = oc.observable(false);
        self.isReplacedEntity = false;
        self.isReplacingWithIndices = false;

        self.savedTemplates = oc.observableArray([]);
        self.selectedTemplate = oc.observable();
        self.selectedAnnotationPane = oc.observable();
        self.selectedAnnotationPaneObj = oc.observable();
        self.selectedAnnotationChartObj = oc.observable();
        //export foot notes
        self.footnoteExportSchema = oc.observable();

        self.globalRelativity = oc.observable(CBModels.Relativity.None);

        if (!common.isOffice) {
            require(["models/dashboard/shared/common"], (commonModel: any) => {
                intraday.realTimeModel = commonModel;
                intraday.realTimeModel.dal.open();
                var keyCurrency = _.get(securityClient.userProfile(), 'KeyCurrency', '');

                if (keyCurrency) {
                    intraday.realTimeModel.dal.changeCurrency(keyCurrency);
                }
            });
        }

        // Set applied colorPalette to null at the time of page binding
        // Bug#2035613
        gUtils.AppliedColorPalette = null;

        self.preservedMetrics = oc.observableArray([]);    // Office, Load Chart - preserved metrics
        self.preservedEntities = oc.observableArray([]);                    // Office, Load Chart - preserved entities

        //#region Chart Level declaration
        self.previousEntities = oc.observableArray([]);
        self.validatingNokeyDevs = oc.observableArray([]);
        self.entitySelectedValue = oc.observableArray([]); // Entity Common Control Objects
        self.metricsSelectedValues = oc.observableArray([]); // Metric Common Control Objects
        self.actualData = oc.observableArray([]);
        self.yAxes = oc.observableArray([]);                // y Axis Collection, will be a part of chart builder instance
        // #region Create Chart Builder instance
        self.forcedPartials = oc.observableArray([]); // partial status keydev dropdown
        self.miTreeSetSelectedValue = oc.observable(true);

        self.showVolumeMessage = oc.observable(false);
        //var defaultChartId: any = _.uniqueId("mi-stockchart-");
        var defaultChartId: any = "mi-stockchart-" + 1;

        self.getDefaultSettingsForSideBar = function (): CBModels.SidebarSettings {
            var subTitleFont = gUtils.getDefaultFontSettings(gUtils.settingsType.subTitleSettings),
                titleFont = gUtils.getDefaultFontSettings(gUtils.settingsType.titleSettings),
                xAxisFont = gUtils.getDefaultFontSettings(gUtils.settingsType.xAxisSettings),
                legendNameFont = gUtils.getDefaultFontSettings(gUtils.settingsType.legendSettings),
                xAxisLabelFont = gUtils.getDefaultFontSettings(gUtils.settingsType.xAxisLabelFontSettings);
            return {
                titleFontSettings: oc.observable(titleFont),
                subTitleFontSettings: oc.observable(subTitleFont),
                xAxisFontSettings: oc.observable(xAxisFont),
                legendFontSettings: oc.observable(legendNameFont),
                xAxisLabelFontSettings: oc.observable(xAxisLabelFont),
                gridLinesEnabled: oc.observable(true)
            };
        };

        self.getChartBuilderInstanceDefaultState = function (): CBModels.ChartBuilder {

            var defaultSideBarSettings = self.getDefaultSettingsForSideBar();

            var firstPane: CBModels.Pane = {
                id: 1,
                name: oc.observable('Pane 1'),
                isActive: true,
                yAxisCollection: oc.observableArray([]) as KnockoutObservableArray<CBModels.Yaxis>,
                seriesCollection: oc.observableArray([]) as KnockoutObservableArray<CBModels.Series>,
                chartId: defaultChartId,
                settings: oc.observable(defaultSideBarSettings),
                isChildPane: false,
                childPaneIds: [],
                selectedSeriesIds: [],
                paneKeyDevTypeIds: [],
                paneKeyDevs: []
            };

            var chartEndDateRange: any = null;
            var chartStartDateRange: any = null;

            var tempDateRange: CBModels.ChartDateRange = {
                end: chartEndDateRange,
                isStaticTimeFrameEnabled: true,
                start: chartStartDateRange,
                staticTimeFrameText: '1Y',
                staticTimeFrameValue: 6
            };
            var chartDateRange = oc.observable(tempDateRange);

            var tempPlottedDateRange: CBModels.PlottedDateRangeI = {
                end: chartEndDateRange,
                start: chartStartDateRange
            };
            var plottedDateRange = oc.observable(tempPlottedDateRange);
            return {
                entities: oc.observableArray([]) as KnockoutObservableArray<CBModels.Entity>,
                metrics: oc.observableArray([]) as KnockoutObservableArray<CBModels.Metric>,
                panes: oc.observableArray([firstPane]) as KnockoutObservableArray<CBModels.Pane>,
                chartDateRange: chartDateRange,
                plottedDateRange: plottedDateRange,
                seriesTypeUpdated: () => { },
                reloadAgGrid: oc.observableArray(false),
                dataLabelsCallBack: () => { },
                globalDataLabelsCallBack: () => { },
                seriesUpdatedCallBack: () => { }
            };
        };
        self.chartBuilderInstance = self.getChartBuilderInstanceDefaultState();    // Chart Object

        MIChartBuilderCommon.chartBuilderCommonObject.chartBuilderInstance = self.chartBuilderInstance;
        window.chartBuilderInstance = self.chartBuilderInstance;

        logOfficeMessages("binding start");

        self.isOffice = oc.observable(common.isOffice);

        self.keyDevTypes = oc.observableArray([]);
        chartDataModel.getKeyDevTypes().then(function (types: CBModels.KeyDevType[]) {
            self.keyDevTypes(types);
        });

        chartBuilderDataStorageModel.getSavedCharts().then(function (saved: any) {
            //filter savetemplates
            saved = _.filter(saved, function (item: any) {
                if (item.SavedChartTemplate) {
                    item.Name = item.Name.replace(/chartTemplate_/, '');
                    item.Name = item.Name.replace(/&amp;/g, '&').replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                    return item;
                }

            });

            //for static 
            self.savedTemplates.push({ key: 0, text: 'Select Template' });

            _.forEach(saved, function (tmpl: any) {
                var optionsData = { key: tmpl.Key, text: tmpl.Name };
                self.savedTemplates.push(optionsData);
            });


        });

        self.currentActivePane = oc.observable();
        self.currentActivePane(self.chartBuilderInstance.panes()[0]);
        self.compComplete = oc.observable(false);

        //#region Office Flags
        self.isOfficeInsertMode = oc.observable(false);
        self.isOfficeUpdateMode = oc.observable(false);
        self.isOfficeRefreshMode = oc.observable(false);
        self.isChartDataReadyToInsert = oc.observable(false);
        self.isGetChartSVGCalled = oc.observable(false);
        self.isAnnotationsDataReadyToInsert = oc.observable(false);

        MIChartBuilderCommon.chartBuilderCommonObject.isAnnotationsReady = oc.observable(false);

        self.inProgressSeries = oc.observableArray([]);

        MIChartBuilderCommon.chartBuilderCommonObject.isSideBarExpanded = oc.observable(false);
        MIChartBuilderCommon.chartBuilderCommonObject.updateSeriesCol = oc.observable([]);
        MIChartBuilderCommon.chartBuilderCommonObject.isPlattsEnabled = self.isPlattsEnabled;

        MIChartBuilderCommon.chartBuilderCommonObject.globalFontSettings = oc.observable();

        if (!self.isStockChart() && !self.isPlattsEnabled) {
            document.title = webStrings.chartBuilderPageTitle();
        }

        self.openAddSeries = oc.observable(false);
        //#region reset Chart Builder

        //#endregion

        //#region Pane/ Series
        self.panesCollection = self.chartBuilderInstance.panes;

        self.firstPane = oc.computed(function () {
            var panes: any = _.get(self, 'chartBuilderInstance.panes');
            return _.first(panes());


        });

        MIChartBuilderCommon.chartBuilderCommonObject.indexDate.subscribe(function () {
            let seriesCollection = gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes());
            let relativeCapableStdDevSeries = _.filter(seriesCollection, function (series: any) {
                return series.isStudy && series.studyType === gUtils.StudyType.SD
                    && gUtils.isRelativeCapableSiri(series);
            });
            if (relativeCapableStdDevSeries.length > 0) {
                self.updateSeriesFromTimeFrame(true, undefined, false, relativeCapableStdDevSeries);
            }
        });

        self.firstPaneSeries = oc.computed(function () {

            var currPane: any = '';
            if (self.selectedAnnotationPane()) {
                currPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === self.selectedAnnotationPane(); });
                //self.selectedKeyDevSeriesIds(currPane.selectedSeriesIds);
            } else {
                currPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === 1; });
            }
            let currChart: any = gUtils.findHighchartById(self.view, _.get(currPane.id, 'chartId'));

            self.selectedAnnotationPaneObj(currPane);
            self.selectedAnnotationChartObj(currChart);
            //self.selectedSeriesIds(currPane.selectedSeriesIds);
            self.selectedKeyDevSeriesIds(currPane.selectedSeriesIds);
            self.selectedKeyDevTypeIds(currPane.paneKeyDevTypeIds);
            self.keyDevs(currPane.paneKeyDevs);
            self.miTreeSetSelectedValue(true);

            return _.get(currPane, 'seriesCollection');
            //return _.get(self.firstPane(), 'seriesCollection');
        });

        self.firstPaneSeriesArr = oc.computed(function () {
            return self.firstPaneSeries()();
        });

        oc.computed(function () {
            var seriesCollection = _.map(self.chartBuilderInstance.panes(), function (pane: any) { return pane.seriesCollection(); });
            self.allPanesSeriesArr(_.flatten(seriesCollection));
        });

        self.sidebarSelectedPaneId = oc.observable(_.get(self.firstPane(), 'id'));

        self.sidebarSelectedPaneSeries = _.get(self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1], 'seriesCollection');
        self.sidebarSelectedPaneSeriesArr = oc.observable(self.sidebarSelectedPaneSeries());

        self.sidebarSelectedYAxes = _.get(self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1], 'yAxisCollection');
        self.sidebarSelectedPaneYAxes = oc.observable(self.sidebarSelectedYAxes());
        //#endregion

        self.officeExportChart = new (OfficeChartingViewModel as any)(self);

        oc.subscribe(self.selectedTemplate, function (val: any) {
            if (val !== 0 && self.previousSelectedTemplate !== val) {

                var savedChartKey = val;
                chartBuilderDataStorageModel.getSavedChartMetaData(savedChartKey).then(function (savedChartMetaData) {
                    var panes = JSON.parse(savedChartMetaData.Panes);
                    var panesData: any = '';
                    let chartBuilderData = {
                        entities: JSON.parse(savedChartMetaData.Entities),
                        //entities: data,
                        metrics: gUtils.formatMetrics(JSON.parse(savedChartMetaData.Metrics)),
                        panes: panes,
                        chartDateRange: JSON.parse(savedChartMetaData.Timeframe),
                        selectedSavedChart: savedChartKey,
                        globalSettings: {
                            relativity: _.get(panes[0], 'settings.globalRelativity', 0)
                        }
                    };

                    if (self.chartBuilderInstance.entities().length === 0) {
                        dialog.show(new LoadTemplateViewModel()).then(function (data: any) {
                            if (data) {
                                self.previousSelectedTemplate = val;
                                panesData = loadTemplateUtil.applyTemplate(chartBuilderData, data, self.keyDevTypes());
                                self.previousSelectedTemplate = val;
                                self.plotSavedChart(panesData);
                            }
                            else {
                                self.selectedTemplate(self.previousSelectedTemplate);
                            }
                        });
                    }
                    else {
                        dialog.show(new ApplyTemplateConfirmationDialogViewModel()).then(function (data: any) {
                            if (data) {
                                var cloneSelctedEnities = _.clone(self.chartBuilderInstance.entities(), true);
                                panesData = loadTemplateUtil.applyTemplate(chartBuilderData, cloneSelctedEnities, self.keyDevTypes());
                                self.previousSelectedTemplate = val;
                                self.plotSavedChart(panesData);
                            } else {
                                self.selectedTemplate(self.previousSelectedTemplate);
                            }
                        });
                    }
                });
            } else {
                self.previousSelectedTemplate = val;
                self.selectedTemplate(val);
            }

        });



        //#region Collecting data from entity common control
        oc.subscribe(self.entitySelectedValue, function (changedEntities: any[]) {

            self.isReplacedEntity = replaceEntityUtil.checkIsReplaceEntity(changedEntities) && self.chartBuilderInstance.metrics().length > 0;
            self.isReplacingWithIndices = self.isReplacedEntity ? gUtils.isVolumeRestrictedEntity(_.find(changedEntities, (x: any) => x.status === 'added').value.data.ContentId) : false;
            if (self.isReplacedEntity) {
                replaceEntityUtil.getSeriesSettingsByEntityId(changedEntities);
            }

            function createPlattsUOMRequest(entities: any[]) {
                var requests = entities.map((ent: any, i: number) => {
                    return {
                        "entityId": ent.value.data.KeyUniversalEntity,
                        "fieldIdentifier": "320317",
                        "correlationId": i
                    };
                });

                return {
                    requests: requests
                };
            }

            function addPlattsCurrency(entityData: any, entities: any) {
                entityData.entityResults.forEach((ent: any) => {
                    entities[ent.correlationId].value.data.magnitude = _.trim(ent.data);
                });

                return entities;
            }

            var addedEntities = _.filter(changedEntities,
                (x: any) => x.status === "added");

            if (self.isPlattsEnabled) {
                dataSeriesModel.getDataSeries2(createPlattsUOMRequest(addedEntities)).
                    then((data: any) => addPlattsCurrency(data, changedEntities)).
                    then((values: any) => processChangedEntities(values));
            } else {
                processChangedEntities(changedEntities);
            }

            function processChangedEntities(values: any) {
                values = gUtils.removeDuplicateObjects(values);

                if ((values) && (values.length > 0)) {

                    if ((self.isStockChartModeEnabled)) {           // don't consider as resolved
                        gUtils.removeAutoResolveEntityFlag(values);
                    }

                    var isSwitchOffRequire = gUtils.isAutoSelectedMetricsSwitchOffRequire(values);
                    if (isSwitchOffRequire) {
                        gUtils.switchOffAutoResolveObjects(self.chartBuilderInstance.metrics);
                    }
                }

                var newlyAddedEntities = gUtils.getCollectionByStatus(values, 'added');
                var newlyDeletedEntities = gUtils.getCollectionByStatus(values, 'deleted');
                let sequenceIdofRemovedEntity: number = 0;
                if ((newlyDeletedEntities) && (newlyDeletedEntities.length > 0)) {
                    var removableEntities: Array<any> = [];
                    _.each(newlyDeletedEntities, function (entity: any) {
                        //added below line to set ispreserved property false for removed metrics bug ID#1734309
                        entity.isPasted = false;
                        var entityObj = _.find(self.chartBuilderInstance.entities(), function (chartBuilderEntity: any) {
                            return chartBuilderEntity.id === entity.id;
                        });
                        if (entityObj) {
                            removableEntities.push(entityObj);
                        }
                    });
                    sequenceIdofRemovedEntity = self.isReplacedEntity ? removableEntities[0].sequenceId : sequenceIdofRemovedEntity;
                    self.chartBuilderInstance.entities.removeAll(removableEntities);
                }

                if ((newlyAddedEntities) && (newlyAddedEntities.length > 0)) {
                    let sequeneceId = 0, multipleEntitiesAdded = newlyAddedEntities.length > 1;
                    if (newlyAddedEntities.length > 1) {
                        sequeneceId = self.chartBuilderInstance.entities().length === 0 ? 0 : _.max(self.chartBuilderInstance.entities().map((x: any) => x.sequenceId)) as number + 1;
                    }
                    var addableEntities = newlyAddedEntities.map(function (value: any) {
                        value.data.isStaticEntity = self.openAddSeries() ? true : false;
                        //setting Squence Id for entity to handle while replacing the entity
                        value.data.sequenceId = multipleEntitiesAdded ? sequeneceId : self.chartBuilderInstance.entities().length === 0 ? 0 : self.isReplacedEntity ? sequenceIdofRemovedEntity : _.max(self.chartBuilderInstance.entities().map((x: any) => x.sequenceId)) as number + 1;
                        sequeneceId = sequeneceId + 1;
                        return imposition.getEntityInstance(value.data, value.isPasted);
                    });
                    ko.utils.arrayPushAll(self.chartBuilderInstance.entities, addableEntities);
                }



            }

        }, null, "arrayChange");

        //#region collecting data from metric common control
        oc.subscribe(self.metricsSelectedValues, function (values: any) {

            if ((values) && (values.length > 0)) {

                if ((self.isStockChartModeEnabled)) {           // don't consider as resolved
                    gUtils.removeAutoResolveMetricFlag(values);
                }

                var isSwitchOffRequire = gUtils.isAutoSelectedEntitiesSwitchOffRequire(values);
                if (isSwitchOffRequire) {
                    gUtils.switchOffAutoResolveObjects(self.chartBuilderInstance.entities);
                }
            }

            var newlyAddedMetrics = gUtils.getCollectionByStatus(values, 'added');
            var newlyDeletedMetrics = gUtils.getCollectionByStatus(values, 'deleted');

            if ((newlyAddedMetrics) && (newlyAddedMetrics.length > 0)) {
                var addableMetrics = newlyAddedMetrics.map(function (value: any) {
                    value.field().isStaticMetric = self.openAddSeries() ? true : false;
                    return imposition.getMetricInstance(value);
                });
                ko.utils.arrayPushAll(self.chartBuilderInstance.metrics, addableMetrics);
            }

            if ((newlyDeletedMetrics) && (newlyDeletedMetrics.length > 0)) {
                var removableMetrics: Array<any> = [];
                _.each(newlyDeletedMetrics, function (metric: any) {
                    //added below line to set ispreserved property false for removed metrics bug ID#1734309
                    metric.field().isPreservedField = false;
                    var metricObj = _.find(self.chartBuilderInstance.metrics(), (chartBuilderMetric: any) => chartBuilderMetric.uUID === metric.uUID);
                    if (metricObj) {
                        removableMetrics.push(metricObj);
                    }
                });
                self.chartBuilderInstance.metrics.removeAll(removableMetrics);

                //if timeframe is static then call the below to set original start date
                if (self.chartBuilderInstance.chartDateRange().isStaticTimeFrameEnabled) {
                    self.restStartDateOnMetricDelete();
                }
            }

        }, null, "arrayChange");

        //#region Add Series
        oc.subscribe(self.chartBuilderInstance.entities, function (entitiesCollection: any) {
            var newlyAddedEntities = gUtils.getCollectionByStatus(entitiesCollection, 'added');
            var newlyDeletedEntities = gUtils.getCollectionByStatus(entitiesCollection, 'deleted');

            if (_.isArray(newlyAddedEntities) && newlyAddedEntities.length > 0 && !self.openAddSeries()) {
                self.addSeriesFromTopBarEntity(newlyAddedEntities);
            }
            if (_.isArray(newlyDeletedEntities) && newlyDeletedEntities.length > 0 && !self.openAddSeries()) {
                self.removeTargetSeriesCollectionByElement(newlyDeletedEntities, 'entity');
                self.disableAutoOpen = false;
                //if removed an entity , try to plot volume series for the next valid entity
                self.updateVolumeSeries(_.isArray(newlyDeletedEntities) ? newlyDeletedEntities[0] : newlyDeletedEntities);
            }
        }, null, "arrayChange");

        self.addSeriesFromTopBarEntity = function (entityCollection: any) {
            if (gUtils.checkIfDuplicateSeriesInMetricEqui(self.chartBuilderInstance.panes()[0].seriesCollection(), entityCollection)) { return; }
            var entityMetricsCollection = gUtils.getEntityMetricsCartesianProduct(entityCollection, self.chartBuilderInstance.metrics());
            if (_.isArray(entityMetricsCollection) && entityMetricsCollection.length > 0) {
                self.addSeries(entityMetricsCollection);
            }
        };
        self.updateVolumeSeries = function (newlyDeletedEntity: any) {
            if (!self.isReplacedEntity || (self.isReplacedEntity && self.isReplacingWithIndices)) {
                let canPlotVolumeSeries = !gUtils.isVolumeRestrictedEntity(newlyDeletedEntity.contentSet) //the delted one should not be an indices/rate & yield
                    && _.filter(self.chartBuilderInstance.metrics(), (x: any) => gUtils.isEquivalancyVolumeMetric(x.key)).length > 0//chart builder contains volume metric
                    && !_.contains(_.pluck(_.filter(self.chartBuilderInstance.panes()[0].seriesCollection(), (x: any) => x.metric.isStaticMetric !== true), 'metric.key'), 290942)//deleted entity is already plotted volume metric
                    && !_.contains(_.pluck(_.filter(self.chartBuilderInstance.panes()[0].seriesCollection(), (x: any) => x.metric.isStaticMetric !== true), 'metric.key'), 319625);//deleted entity is already plotted volume metric

                let nextValidEntity = _.find(self.chartBuilderInstance.entities(), (x: any) => !gUtils.isVolumeRestrictedEntity(x.contentSet));

                if (canPlotVolumeSeries) {
                    _.each(_.filter(self.chartBuilderInstance.metrics(), (x: any) => gUtils.isEquivalancyVolumeMetric(x.key)), function (x: CBModels.Metric) {
                        x.singleSelectableMetricUsed = false;
                    });
                }
                if (canPlotVolumeSeries && nextValidEntity) {
                    var entityMetricsCollection = gUtils.getEntityMetricsCartesianProduct([nextValidEntity], [_.find(self.chartBuilderInstance.metrics(), (x: any) => gUtils.isEquivalancyVolumeMetric(x.key))]);
                    if (_.isArray(entityMetricsCollection) && entityMetricsCollection.length > 0) {
                        self.addSeries(entityMetricsCollection, true);
                    }
                }
            }
        };
        oc.subscribe(self.chartBuilderInstance.metrics, function (metricsCollection: any) {
            var newlyAddedMetrics = gUtils.getCollectionByStatus(metricsCollection, 'added');
            var newlyDeletedMetrics = gUtils.getCollectionByStatus(metricsCollection, 'deleted');

            if (_.isArray(newlyAddedMetrics) && newlyAddedMetrics.length > 0 && !self.openAddSeries()) {
                self.addSeriesFromTopBarMetric(newlyAddedMetrics);
            }
            if (_.isArray(newlyDeletedMetrics) && newlyDeletedMetrics.length > 0 && !self.openAddSeries()) {
                self.removeTargetSeriesCollectionByElement(newlyDeletedMetrics, 'metric');
            }
            self.showVolumeMessage(_.filter(self.chartBuilderInstance.metrics(), (x: any) => gUtils.isEquivalancyVolumeMetric(x.key)).length > 0);
        }, null, "arrayChange");

        self.addSeriesFromTopBarMetric = function (metricsCollection: any) {
            var entityMetricsCollection = gUtils.getEntityMetricsCartesianProduct(self.chartBuilderInstance.entities(), metricsCollection);
            if (_.isArray(entityMetricsCollection) && entityMetricsCollection.length > 0) {
                self.addSeries(entityMetricsCollection);
            }
            //            self.chartChangedCB();
        };

        //resetting to actual start date after removing the metric
        //to resolve the bug #1841320
        self.restStartDateOnMetricDelete = function () {
            //Logic: changing start date to actual start date and updating the series.
            let originalStartDate = self.chartBuilderInstance.chartDateRange().start;
            self.chartBuilderInstance.plottedDateRange().start = originalStartDate;
            self.updateSeriesFromTimeFrame(false, undefined, true, [], false);
        };


        self.calcBenchMarkSeries = function (seriesColl: any, updateTimeFrame: boolean) {
            var currChart = gUtils.findHighchartById(self.view, _.get(self.firstPane(), 'chartId'));
            //var uiPanes: any = self.chartBuilderInstance.panes()[0];
            var bMSeriesColl: any = _.filter(seriesColl, 'isBenchMark', true);
            _.each(bMSeriesColl, function (bmSeri: any) {
                var bSeries: any = _.find(seriesColl, function (series: any) {
                    return series.seriesId === bmSeri.seriesId;
                });
                var pSeries: any = _.find(seriesColl, function (series: any) {
                    return series.seriesId === bSeries.parentSeriesId;
                });

                var hsSeries = _.find(currChart.series, function (series: any) {
                    return series.userOptions.id === pSeries.seriesId;
                });
                //var isRelative = hsSeries && hsSeries.data.length > 0 && hsSeries.data[0].meta.mag === "%" ? true : false;

                var isRelative = hsSeries && hsSeries.data.length > 0 && pSeries.data[0][2] === "%" ? true : false;
                if (updateTimeFrame) {
                    isRelative = false;
                }
                var finalBMData: any = gUtils.getBenchMarkSeries(bSeries.data, pSeries.data, isRelative);

                finalBMData = _.filter(finalBMData, function (point: any) { return !_.isNaN(point[1]); });

                if (hsSeries) {
                    var siriData = _.map(finalBMData, gUtils.transformDataPointArrayToObj);
                    hsSeries.setData([]);
                    hsSeries.setData(siriData);
                }

                _.each(currChart.yAxis, function (yAxis: any) {
                    var hasVisibleSeries = _.some(_.get(yAxis, 'series', []), function (siri: any) {
                        return siri.visible;
                    });

                    if (hasVisibleSeries) {
                        yAxisUtil.updateYAxisExtremes(true, yAxis, currChart.yAxis, undefined, undefined, undefined, undefined);
                    }
                    yAxisUtil.updateYAxisLabel(yAxis, false, self.isPlattsEnabled);
                    var hasVisibleBenchMarkSeries = _.some(_.get(yAxis, 'series', []), function (siri: any) {
                        return siri.userOptions.benchMarkEntities && siri.userOptions.benchMarkEntities.length > 0
                            && siri.visible;
                    });

                    if (hasVisibleBenchMarkSeries && !gUtils.hasPlotline(yAxis)) {
                        yAxis.update({
                            plotLines: [{
                                value: 0,
                                color: '#808080',
                                width: 2,
                                zIndex: 5,
                                id: 'Plotline-1'
                            }]
                        }, true);
                    }
                });
            });
        };

        // We rollback start date to previous date when data for the selected start date in timeframe is not available.
        // In case of multiple series, start date for all series should be minimum date.
        // This logic has been applied to resolve Bug# 1299589
        self.adjustStartDate = function (updateTimeFrame: boolean = false) {
            // var series = self.chartBuilderInstance.panes()[0].seriesCollection();
            let series = gUtils.getAllUISeries();
            interface SeriesDataHolder {
                data: any;
                isPeriodic: boolean;
                isBenchMark: boolean;
                seriesId: any;
            }

            var seriesDataPromises = _.map(series, (siri: any) => {
                return siri.data.then((data: any) => {
                    return {
                        data: data,
                        isPeriodic: siri.isPeriodic,
                        isBenchMark: siri.isBenchMark,
                        seriesId: siri.id,
                        parentSeriesId: siri.parentSeriesId,
                        isIntraday: intraday.isIntradayCapableSeries(siri.entity.contentSet, siri.metric.key, siri.metric.secondaryKeys)
                    } as SeriesDataHolder;
                });
            });

            q.all(seriesDataPromises).then(function (allResults: SeriesDataHolder[]) {
                var result = _.pluck(_.filter(allResults, function (seri: any) {
                    return !seri.isPeriodic && !seri.isBenchMark;
                }), 'data');



                if (_.some(_.flatten(result))) {
                    let resultWithData = _.filter(result, function (data: any) { return data.length > 0; });
                    var minDate = _.map(resultWithData, function (data: any) {
                        return data[0][0] instanceof Date ? data[0][0].valueOf() : data[0][0];
                    });

                    if (updateTimeFrame || minDate && _.some(minDate) && !_.every(minDate, function (date: any) { return date === minDate[0]; })) {
                        var originalStartDate = self.chartBuilderInstance.chartDateRange().start;
                        var originalPlottedStartDate = self.chartBuilderInstance.plottedDateRange().start;

                        self.chartBuilderInstance.chartDateRange().start = moment(new Date(_.min(minDate))).format('YYYYMMDD');
                        self.chartBuilderInstance.plottedDateRange().start = moment(new Date(_.min(minDate))).format('YYYYMMDD');

                        let isAnyListTypeSeries: boolean = true;
                        for (let series of gUtils.findHighchartById(self.view, _.get(self.firstPane(), 'chartId')).series) {
                            if (series.userOptions.entity.contentSet !== 10) {
                                isAnyListTypeSeries = false;
                            }
                        }
                        if (isAnyListTypeSeries) {
                            self.chartBuilderInstance.chartDateRange().start = originalStartDate;
                            self.chartBuilderInstance.plottedDateRange().start = originalPlottedStartDate;
                            self.updateSeriesFromTimeFrame(false, undefined, false, [], true);
                        }
                        else {
                            self.updateSeriesFromTimeFrame(false, undefined, false, [], true, true);
                            //TODO: Incorrect            self.updateSeriesFromTimeFrame(false, undefined, false, true);
                            self.chartBuilderInstance.chartDateRange().start = originalStartDate;
                            self.chartBuilderInstance.plottedDateRange().start = originalPlottedStartDate;
                        }
                    }
                }
                else if (_.some(allResults, 'isIntraday') || (!_.some(_.flatten(result)) && result.length > 0)) {
                    self.updateSeriesFromTimeFrame(false, undefined, false, [], true, true);
                }
                self.calcBenchMarkSeries(allResults, updateTimeFrame);
            });
        };

        //To check whether series is priodic or not.
        var isAllPeriodic = (series: any[]) => _.every(series, 'userOptions.isPeriodic');

        self.updateSeriesFromTimeFrame = function (datesChangedByButton: any, currency: any, shouldAdjustStartDate: any, editableSeries: Array<any> = [], isFromAdjustStartDate: boolean = false, isFromTimeframeAnnt: boolean = false) {
            //findout series which required service call.
            var serviceReqSeries: Array<any> = editableSeries.length > 0 ? editableSeries : [];
            var currChart = gUtils.findHighchartById(self.view, _.get(self.firstPane(), 'chartId'));
            if (currChart && currChart.SkipTimeframeUpdate) {
                currChart.SkipTimeframeUpdate = false;
                return;
            }

            var chartDateRange = self.chartBuilderInstance.chartDateRange;
            var stDate = chartDateRange().start.slice(0, 4) + "/" + chartDateRange().start.slice(4, 6) + "/" + chartDateRange().start.slice(6, 8);
            var edDate = chartDateRange().end.slice(0, 4) + "/" + chartDateRange().end.slice(4, 6) + "/" + chartDateRange().end.slice(6, 8);
            currChart.startDate = stDate;
            currChart.endDate = edDate;

            if (editableSeries.length === 0) {
                _.each(gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()), function (s: any) {
                    //to make  isCallByTimeframe as on adding other metrics along with DCP(candlestick)
                    if ((s.chartType === gUtils.ChartType.Candlestick || s.chartType === gUtils.ChartType.OHLC) && isFromAdjustStartDate) {
                        s.isCallByTimeframe = s.isCallByTimeframe === undefined ? true : s.isCallByTimeframe;
                    } else if (s.chartType === gUtils.ChartType.Candlestick || s.chartType === gUtils.ChartType.OHLC) {
                        s.isCallByTimeframe = true;
                    }
                    if (currency !== undefined && currency !== null && !datesChangedByButton) {
                        s.currency = currency;
                        serviceReqSeries.push(s);
                    }
                    else {
                        serviceReqSeries.push(s);
                        if (s.currSeriesTimePos.value < self.globalPos.currTimePos.value || !datesChangedByButton) {
                            s.currSeriesTimePos = self.globalPos.currTimePos;
                        }

                        if (!datesChangedByButton) {
                            s.currSeriesTimePos = $.extend(true, {}, self.globalPos.currTimePos.value);
                            s.currSeriesTimePos.value = 0;
                        }
                    }
                });
            }

            _.each(serviceReqSeries, function (series: any) {

                if (isFromTimeframeAnnt) {
                    let timeDuration = intraday.getDateDifference(self.chartBuilderInstance.chartDateRange().start, self.chartBuilderInstance.chartDateRange().end);
                    let hasFrequencyUpdated = gUtils.adjustMetricsParameters(series, self.metricsSelectedValues, timeDuration);
                    let FrequencyChangedForIntraday = intraday.manageSeriesFrequency(series, self.metricsSelectedValues);
                    if (hasFrequencyUpdated || FrequencyChangedForIntraday) {
                        MIChartBuilderCommon.chartBuilderCommonObject.chartBuilderInstance.reloadAgGrid(true);
                        self.firstPaneSeriesArr.notifySubscribers(self.firstPaneSeriesArr());
                    }
                }

                var periodType = _.find(series.metric.secondaryKeys, function (sk: any) {
                    let secondaryKeys = ["cht_01", "cht_03", "cht_06"];
                    let searchKey = sk.key ? sk.key : sk.keyJoinHint;
                    return secondaryKeys.indexOf(searchKey) > -1;
                });

                var frequency = _.find(series.metric.secondaryKeys, function (sk: any) {
                    let secondaryKeys = ["cht_02", "cht_04", "cht_07"];
                    let searchKey = sk.key ? sk.key : sk.keyJoinHint;
                    return secondaryKeys.indexOf(searchKey) > -1;
                });
                var offset = _.find(series.metric.secondaryKeys, function (sk: any) {
                    let secondaryKeys = ["cht_05", "cht_08", "cht_09"];
                    let searchKey = sk.key ? sk.key : sk.keyJoinHint;
                    return secondaryKeys.indexOf(searchKey) > -1;
                });

                let entityId: string;
                // entity id to be retrieved from getEntityIdString method of generic util for entity type equity and total return metric
                if (series.entity.entityTypeFct === gUtils.entityCategory.equities && series.metric.key === 290952) {
                    entityId = gUtils.getEntityIdString(series.entity);
                } else {
                    entityId = series.entity.keyUniversalEntity || series.entity.companySnlKeyInstn || gUtils.getEntityIdString(series.entity);
                }
                var contentSet: any = series.entity.contentSet;

                let dataFromCacheOnly = false;
                let extendedFields: any[] = [];
                let isCandlestick = false;

                if (_.contains([gUtils.ChartType.Candlestick, gUtils.ChartType.OHLC], series.chartType)) {
                    extendedFields = ["319188", "290931", "290932"];
                    isCandlestick = true;
                }

                let seriesMetricKey = series.metric.key;
                if (series.entity.contentSet !== 6 && series.metric.key === gUtils.equivalancyTotalReturnMetrics[1].key) {
                    seriesMetricKey = gUtils.equivalancyTotalReturnMetrics[0].key;
                } else if (series.entity.contentSet === 6 && series.metric.key === gUtils.equivalancyTotalReturnMetrics[0].key) {
                    seriesMetricKey = gUtils.equivalancyTotalReturnMetrics[1].key;
                }
                // if StudyType is OBV first we are fetching volume data. 
                if (series.isStudy && series.studyType === gUtils.StudyType.OBV) {
                    seriesMetricKey = 290942;// if type is OBV passing data series should be Volume
                }
                series.data = chartDataModel.getSeriesData(
                    entityId,
                    seriesMetricKey,
                    self.chartBuilderInstance.chartDateRange,
                    {
                        periodType: periodType ? periodType.value : gUtils.getDefaultPeriodType(series.metric),
                        frequency: frequency ? frequency.value : (gUtils.isEstimate(series.metric, true) ? "1" : "daily"),
                        currency: series.currency,
                        dataFromCacheOnly: dataFromCacheOnly,
                        isStudy: series.isStudy,
                        studyType: series.studyType,
                        studyPeriod: series.studyPeriod,
                        studyStdDev: series.studyStdDev,
                        studySeqId: series.studySeqId,
                        indexDate: series.isStudy && gUtils.isRelativeCapableSiri(series) ? gUtils.getIndexDate(series.id) : null,
                        offset: offset ? offset.value : 1,
                        entityTypeFct: series.entity.entityTypeFct,
                        extendedFields: extendedFields,
                        isCandlestick: isCandlestick,
                        id: gUtils.getListGUID(series.entity),
                        contentSet: series.entity.contentSet,
                        plottedDateRange: self.chartBuilderInstance.plottedDateRange,
                        isStaticTimeFrameEnabled: datesChangedByButton,
                        entityName: series.entity.name,
                        isEstimate: gUtils.isEstimate(series.metric, true),
                        isForward: gUtils.isForward(series.metric),
                        ratesKeyEntityType: series.entity.ratesKeyEntityType,
                        obvData: [],
                        cdsMetricSKeys: gUtils.getCdsMetricSKeys(series.metric) !== null ? gUtils.getCdsMetricSKeys(series.metric) : null, // Pulling default cds metric default Secondary keys option.
                        localizedCaption: series.metric.localizedCaption
                    }
                ).then(function (data: any) {
                    // added new condition here for OBV we have to call Dayclose Price data
                    // ** so again calling getSeriesData service call if studyType should OBV 
                    // ** Passing dayClosePrice metric and calculating OBV data in StudiesLib.ts file.
                    //  Need to confirm these changes...
                    if ((series.isStudy && series.studyType === gUtils.StudyType.OBV) || (series.isStudy && series.entity.contentSet === 10 && data.response === "requestback")) {// if study is OBV calling getSeriesData again...
                        return chartDataModel.getSeriesData(
                            entityId,
                            dayClosePrice.key,// passing dayClosePrice Metric Key
                            data.response === "requestback" ? oc.observable(data.chartDateRange) : self.chartBuilderInstance.chartDateRange,
                            {
                                periodType: periodType ? periodType.value : gUtils.getDefaultPeriodType(series.metric),
                                frequency: frequency ? frequency.value : (gUtils.isEstimate(series.metric, true) ? "1" : "daily"),
                                currency: series.currency,
                                dataFromCacheOnly: dataFromCacheOnly,
                                isStudy: series.isStudy,
                                studyType: series.studyType,
                                studyPeriod: series.studyPeriod,
                                studyStdDev: series.studyStdDev,
                                studySeqId: series.studySeqId,
                                indexDate: series.isStudy && gUtils.isRelativeCapableSiri(series) ? gUtils.getIndexDate(series.id) : null,
                                offset: offset ? offset.value : 1,
                                entityTypeFct: series.entity.entityTypeFct,
                                extendedFields: extendedFields,
                                isCandlestick: isCandlestick,
                                id: gUtils.getListGUID(series.entity),
                                contentSet: series.entity.contentSet,
                                plottedDateRange: data.response === "requestback" ? oc.observable(data.plottedDateRange) : self.chartBuilderInstance.plottedDateRange,
                                isStaticTimeFrameEnabled: datesChangedByButton,
                                entityName: series.entity.name,
                                isEstimate: gUtils.isEstimate(series.metric, true),
                                isForward: gUtils.isForward(series.metric),
                                ratesKeyEntityType: series.entity.ratesKeyEntityType,
                                obvData: data,// ** added new option here for handling OBV data and Passing Volume data...,
                                listReqcallback: data.response === "requestback" ? true : false,
                                seriesStartDate: data.seriesStartDate
                            }
                        ).then(function (obvData: any) {
                            return obvData;
                        });

                    } else {// normal flow
                        return data;
                    }
                });
                if (contentSet === 10) {
                    shouldAdjustStartDate = false;
                }
            });
            //   # start region from Time frame update devkey Notes.
            var typeNodeIds = self.selectedKeyDevTypeIds().filter((x: string) => {
                return _.startsWith(x, "type") || x === 'cat:custom';
            });

            var typeIds: CBModels.KeyDevId[] = typeNodeIds.map((x: string) => {
                var idString = x.split(":")[1];
                return idString === "custom" ? "custom" : parseInt(idString);
            });

            var types = anntUtil.getSelectedKeyDevIds(typeIds,
                self.keyDevTypes());

            var handleNoDataMessage = _.debounce(function () { self.handleNoDataMessage(serviceReqSeries); }, 100);

            if ((isAllPeriodic(currChart.series)) && (shouldAdjustStartDate)) {
                shouldAdjustStartDate = false;
            }

            if (serviceReqSeries.length !== 0 && !shouldAdjustStartDate) {
                if (editableSeries.length === 0) {
                    MIChartBuilderCommon.chartBuilderCommonObject.updateSeriesCol(serviceReqSeries);
                }
                else if (_.all(editableSeries, (series: any) => series.studyType === gUtils.StudyType.SD)) {
                    MIChartBuilderCommon.chartBuilderCommonObject.updateSeriesCol(editableSeries);
                }
                else {
                    //let allPanes: any = _.get(self, 'chartBuilderInstance.panes');
                    //let firstPane: any = _.first(allPanes());
                    //let allSeries: any = _.get(firstPane, 'seriesCollection');
                    //MIChartBuilderCommon.chartBuilderCommonObject.updateSeriesCol(allSeries());
                    //Bug 2099111 - updating all pane series
                    MIChartBuilderCommon.chartBuilderCommonObject.updateSeriesCol(self.allPanesSeriesArr());
                }
                //Adding this for all periodic
                if (isAllPeriodic(currChart.series)) {
                    handleNoDataMessage();
                }
            } else if (!currency) {
                handleNoDataMessage(); // Handle no data message when timeframe is changed and currency is not updated
            }

            // //extremes for chart
            //TO-Do: Will refactor following code
            if (currChart.zoomedStartDate) {
                var timeframeNode = $('.time-frame-cotrol');
                var datePickerNodes = timeframeNode.find('.date-picker');
                if ($(datePickerNodes[0]).val() !== currChart.zoomedStartDate) {
                    $('.highcharts-button').hide();
                    delete currChart.timeFrameStartDate;
                    delete currChart.timeFrameEndDate;
                    delete currChart.zoomedStartDate;
                    delete currChart.zoomedEndDate;
                }
            }

            if (self.actualData() && self.actualData().length > 0 && !(_.all(editableSeries, (series: any) => series.studyType === gUtils.StudyType.SD))) {
                // Get Data for selected time frame
                var requiredData: Array<any> = [];
                _.each(self.actualData(), function (data: any) {
                    var relatedSeries = _.find(currChart.series, function (s: any) {
                        return _.get(s, 'userOptions.id', data.id);
                    });

                    requiredData.push({
                        name: data.name,
                        data: _.filter(data.data, function (seriesData: any) {

                            if (seriesData) {
                                seriesData[0] = new Date(seriesData[0]).setHours(0, 0, 0, 0);
                                return seriesData[0] >= Date.parse(stDate) && seriesData[0] <= Date.parse(edDate);
                            }
                            else {
                                return false;
                            }
                        }),
                        metric: data.metric,
                        entity: data.entity,
                        id: data.id,
                        yAxis: _.get(relatedSeries, 'yAxis.userOptions.id')
                    });
                });

                //If Date is relative, make the data relative.

                var yAxisRelativeDates = gUtils.getRelativeDatesByYAxis(requiredData, self.getYAxes());
                var yAxisIndexTos = gUtils.getIndexTosByYAxis(self.yAxes());

                var transformedDatas = gUtils.getChartData(requiredData, yAxisRelativeDates, yAxisIndexTos);

                // Update chart series data based on selected date range
                _.each(currChart.series, function (chartSeries: any) {
                    if (chartSeries.type !== 'flags') {
                        var chartData = _.first(_.filter(transformedDatas, function (data: any) {
                            return data.id === chartSeries.userOptions.id;
                        }));
                        //chartSeries.name = chartData.seriesDisplayName;
                        //chartSeries.userOptions.name = chartData.seriesDisplayName;
                        if (chartData) {
                            chartData.data = _.map(chartData.data, gUtils.transformDataPointArrayToObj);
                            chartSeries.setData(chartData.data, false);
                        }
                    }
                });
            }

            //Updating the annotations
            var selectedSeriesIds = self.selectedKeyDevSeriesIds();
            var selectedSeries = _.filter(self.firstPaneSeriesArr(), (x: any) => {
                return _.contains(selectedSeriesIds, x.id);
            });

            var dateRange = self.chartBuilderInstance.chartDateRange();

            var nodes = self.selectedKeyDevTypeIds();

            if (types.length > 0 && isFromTimeframeAnnt) {
                self.updateKeyDevs(nodes, selectedSeries, dateRange, true, true);
            }

            gUtils.setXAxesExtremes(currChart,
                Date.parse(stDate), Date.parse(edDate));

            _.each(currChart.yAxis, function (yAxis: any) {
                yAxisUtil.updateYAxisExtremes(false, yAxis, self.getYAxes(), undefined, undefined, undefined, undefined);    // To Do : check the data type here - null/undefined
            });

            self.chartChangedCB();

            if (shouldAdjustStartDate) {
                self.adjustStartDate(true);
            }

            self.removeStudiesForIntradaySeries();
        };

        self.removeStudiesForIntradaySeries = function () {

            let collection = gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes());//self.chartBuilderInstance.panes()[0].seriesCollection();
            let parentSeriesIds = _.pluck(_.filter(collection, function (item: any) { return !item.isStudy && intraday.isIntradayCapableSeries(item.entity.contentSet, item.metric.key, item.metric.secondaryKeys); }), 'id');

            if (_.some(parentSeriesIds)) {
                let studiesToRemove = _.filter(collection, (study: any) => _.contains(parentSeriesIds, study.parentSeriesId));
                let isAnyStudyRemoved = false;

                _.each(studiesToRemove, (study: any) => {

                    if (study.isBenchMark) {
                        var parentSeries = _.find(collection, (series: any) => series.id === study.parentSeriesId);
                        self.removeBenchmark(parentSeries);
                    }
                    else {
                        self.removeSeries([study], false, false);
                    }
                    isAnyStudyRemoved = true;
                });


                if (isAnyStudyRemoved) {
                    zone.root.notify({
                        message: webStrings.chartbuilderAnalysisNotSupported(),
                        type: "error",
                        dismiss: true
                    });
                }
            }
        };

        self.handleNoDataMessage = function (newSeries: any) {
            zone.root.clearNotifications();
            q.all(newSeries.map(function (siri: any) {
                return siri.data.then(function (data: any) {
                    return {
                        entity: siri.entity,
                        metric: siri.metric,
                        data: data,
                        color: siri.color
                    };
                });
            })).then(function (collection: any) {
                var seriesWithNoData = _.filter(collection, function (series: any) {
                    var data: any = [];
                    if (series.data) {
                        data = _.compact(series.data.map(function (value: any) { return _.isFinite(value[1]); }));
                    }

                    return data.length === 0;

                });

                if (seriesWithNoData && seriesWithNoData.length > 0) {

                    var seriesNames = '';

                    _.each(seriesWithNoData, function (data: any) {
                        seriesNames = seriesNames + '<br/>' + formationUtil.getFormattedSeriesName(data.entity, data.metric);
                    });

                    self.viewContext.zone.notify({
                        message: stringUtilities.format("{0}:{1}", webStrings.chartBuilderNoDataMessage(), seriesNames),
                        type: "error",
                        dismiss: true
                    });
                }
                //this is to show error message when loaded chart having any deleted saved lists.
                if (self.deletedListInfo.length > 0) {
                    _.each(self.deletedListInfo, function (delList) {
                        self.viewContext.zone.notify({
                            message: delList + ' ' + ' has been deleted and is no longer available in this chart.',
                            type: "error",
                            dismiss: true
                        });
                    });
                    //making it empty to avoid the same toast message on another load chart
                    self.deletedListInfo = [];
                }

            });
        };

        self.getKeydevOpts = function (series: any, defaultKeydevOpts: any) {
            if (series.annotations && !series.keyDevOptions) {
                defaultKeyDevOpts.subsideries = true;
                defaultKeyDevOpts.investments = true;
                return defaultKeydevOpts;
            }
            return series.keyDevOptions || defaultKeyDevOpts;
        };

        self.addSeries = function (newSeriesCollection: any, iscalledFromDeleteEntity: boolean = false) {
            //applying removed series settings
            var currChart = gUtils.findHighchartById(self.view, _.get(self.firstPane(), 'chartId'));
            if (self.isReplacedEntity && !iscalledFromDeleteEntity) {
                newSeriesCollection = replaceEntityUtil.applySeriesSettingOfRemovedEntity(newSeriesCollection, self.keyDevTypes(), currChart);
            }

            var currency: any = null;
            if (crossSiteFilterCurrencyObservable() && crossSiteFilterCurrencyObservable().length > 0) {
                currency = crossSiteFilterCurrencyObservable()[0];
            }

            var seriesCollection = _.map(newSeriesCollection, function (series: any) {
                var contentSet = series.entity.contentSet || series.entity.ContentSet;
                var entityTypeFct = series.entity.entityTypeFct || series.entity.EntityTypeFct;
                var keyInstnId = series.entity.keyUniversalEntity || series.entity.KeyUniversalEntity;
                var snlKeyInstn = series.entity.companySnlKeyInstn || series.entity.CompanySnlKeyInstn;
                var entityName = series.entity.name || series.entity.Name;



                var metric = series.metric;
                if (self.isPlattsEnabled) {
                    metric.defaultMagnitude = series.entity.magnitude;
                }

                if ((metric.keyItem) && (metric.keyItem === "709")) {   // replace by enum
                    metric.defaultMagnitude = "($)";      // not reflected by user setting
                }
                //var newSeriesId = series.isStudy ? (series.id === Math.floor(series.id) ?
                //    gUtils.getStudySeriesId(series.id,
                //        series.studyType,
                //        series.studyPeriod, series.studyStdDev, series.studySeqId) : series.id)
                //    : (series.id ? series.id : self.getSeriesId());
                var newSeriesId = series.id ? series.id : self.getSeriesId();

                let seriesMetricKey = series.metric.key;
                if (contentSet !== 6 && series.metric.key === gUtils.equivalancyTotalReturnMetrics[1].key) {
                    seriesMetricKey = gUtils.equivalancyTotalReturnMetrics[0].key;
                } else if (contentSet === 6 && series.metric.key === gUtils.equivalancyTotalReturnMetrics[0].key) {
                    seriesMetricKey = gUtils.equivalancyTotalReturnMetrics[1].key;
                }
                var isIndividual = series.metric && series.metric.isStaticMetric ? series.metric.isStaticMetric : false;
                if (series.currency) {
                    currency = series.currency;
                    self.currencyFromSaveChart(series.currency);

                }
                self.selectedCurrFromDD(currency);

                var periodType = _.find(series.metric.secondaryKeys, function (sk: any) {
                    let secondaryKeys = ["cht_01", "cht_03", "cht_06"];
                    let searchKey = sk.key ? sk.key : sk.keyJoinHint;
                    return secondaryKeys.indexOf(searchKey) > -1;
                });
                periodType = periodType ? periodType.value : gUtils.getDefaultPeriodType(series.metric);
                var frequency = _.find(series.metric.secondaryKeys, function (sk: any) {
                    let secondaryKeys = ["cht_02", "cht_04", "cht_07"];
                    let searchKey = sk.key ? sk.key : sk.keyJoinHint;
                    return secondaryKeys.indexOf(searchKey) > -1;
                });

                var offset = _.find(series.metric.secondaryKeys, function (sk: any) {
                    let secondaryKeys = ["cht_05", "cht_08", "cht_09"];
                    let searchKey = sk.key ? sk.key : sk.keyJoinHint;
                    return secondaryKeys.indexOf(searchKey) > -1;
                });
                // offset = offset ? offset.value : (periodType === "NTM" ? 0 : 1);
                offset = periodType === "NTM" ? 0 : offset ? offset.value : 1;
                let entityId: string;
                // entity id to be retrieved from getEntityIdString method of generic util for entity type equity and total return metric
                if (entityTypeFct === gUtils.entityCategory.equities && series.metric.key === 290952) {
                    entityId = gUtils.getEntityIdString(series.entity);
                } else {
                    entityId = keyInstnId || snlKeyInstn || gUtils.getEntityIdString(series.entity);
                }
                //following flag is to check the candlestick/ohlc type series on opening saved charts(by checking the ohlsData point for open high low & close )
                // assuming that we always get open , high, low & close points for candlestick types.
                let isCandlestickType: boolean = series.chartType === gUtils.ChartType.Candlestick || series.chartType === gUtils.ChartType.OHLC;

                // if StudyType is OBV first we are fetching volume data. 
                if (series.isStudy && series.studyType === gUtils.StudyType.OBV) {
                    seriesMetricKey = 290942;// if type is OBV passing data series should be Volume
                }
                var seriesObject: CBModels.SeriesExtended = {
                    pinnedAnnotations: series.pinnedAnnotations ? series.pinnedAnnotations : [],
                    annotations: series.annotations ? series.annotations : [],
                    customAnnotations: series.customAnnotations ? series.customAnnotations : [],
                    removedAnnotations: series.removedAnnotations ? series.removedAnnotations : [],
                    chartType: series.chartType ? series.chartType : gUtils.getChartType(series.metric, undefined),
                    color: series.color ? series.color : '',
                    lineWidth: series.lineWidth,
                    dashStyle: series.dashStyle ? series.dashStyle : "Solid",
                    data: chartDataModel.getSeriesData(
                        entityId,
                        seriesMetricKey,
                        self.chartBuilderInstance.chartDateRange,
                        {
                            periodType: periodType,
                            frequency: frequency ? frequency.value : (gUtils.isEstimate(series.metric, true) ? "1" : "daily"),
                            currency: currency,
                            isStudy: series.isStudy,
                            studyType: series.studyType,
                            studyPeriod: series.studyPeriod,
                            studyStdDev: series.studyStdDev,
                            studySeqId: series.studySeqId,
                            indexDate: series.isStudy && gUtils.isRelativeCapableSiri(series) ? gUtils.getIndexDate(newSeriesId) : null,
                            offset: offset,
                            entityTypeFct: entityTypeFct,
                            extendedFields: isCandlestickType ? ["319188", "290931", "290932"] : undefined,
                            isCandlestick: isCandlestickType,
                            dataFromCacheOnly: !isCandlestickType ? undefined : false,
                            id: gUtils.getListGUID(series.entity),
                            contentSet: contentSet,
                            plottedDateRange: self.chartBuilderInstance.plottedDateRange,
                            entityName: entityName,
                            isEstimate: gUtils.isEstimate(series.metric, true),
                            isForward: gUtils.isForward(series.metric),
                            ratesKeyEntityType: series.entity.ratesKeyEntityType,
                            obvData: [],// added new option here for handling OBV data
                            cdsMetricSKeys: gUtils.getCdsMetricSKeys(series.metric) !== null ? gUtils.getCdsMetricSKeys(series.metric) : null,// Pulling default cds metric default Secondary keys option.
                            localizedCaption: series.metric.localizedCaption

                        }
                    ).then(function (data: any) {
                        // added new condition here for OBV we have to call Dayclose Price data
                        // ** so again calling getSeriesData service call if studyType should OBV 
                        // ** Passing dayClosePrice metric and calculating OBV data in StudiesLib.ts file.
                        //  Need to confirm these changes...

                        if ((series.isStudy && series.studyType === gUtils.StudyType.OBV) || (series.isStudy && series.entity.contentSet === 10 && data.response === "requestback")) {// if study is OBV calling getSeriesData again...
                            return chartDataModel.getSeriesData(
                                entityId,
                                dayClosePrice.key,// passing dayClosePrice Metric Key 
                                data.response === "requestback" ? oc.observable(data.chartDateRange) : self.chartBuilderInstance.chartDateRange,
                                {
                                    periodType: periodType,
                                    frequency: frequency ? frequency.value : (gUtils.isEstimate(series.metric, true) ? "1" : "daily"),
                                    currency: currency,
                                    isStudy: series.isStudy,
                                    studyType: series.studyType,
                                    studyPeriod: series.studyPeriod,
                                    studyStdDev: series.studyStdDev,
                                    studySeqId: series.studySeqId,
                                    indexDate: series.isStudy && gUtils.isRelativeCapableSiri(series) ? gUtils.getIndexDate(newSeriesId) : null,
                                    offset: offset,
                                    entityTypeFct: series.entity.entityTypeFct,
                                    extendedFields: (self.isReplacedEntity && isCandlestickType) ? ["319188", "290931", "290932"] : undefined,
                                    isCandlestick: (self.isReplacedEntity && isCandlestickType) ? true : undefined,
                                    dataFromCacheOnly: !isCandlestickType ? undefined : false,
                                    id: gUtils.getListGUID(series.entity),
                                    contentSet: series.entity.contentSet,
                                    plottedDateRange: data.response === "requestback" ? oc.observable(data.plottedDateRange) : self.chartBuilderInstance.plottedDateRange,
                                    entityName: series.entity.name,
                                    isEstimate: gUtils.isEstimate(series.metric, true),
                                    isForward: gUtils.isForward(series.metric),
                                    ratesKeyEntityType: series.entity.ratesKeyEntityType,
                                    obvData: data,// ** added new option here for handling OBV data and Passing Volume data...
                                    listReqcallback: data.response === "requestback" ? true : false,
                                    seriesStartDate: data.seriesStartDate
                                }
                            ).then(function (obvData: any) {
                                return obvData;
                            });

                        } else {// normal flow
                            return data;
                        }
                    }),
                    entity: series.entity,
                    id: series.isStudy ? newSeriesId : (series.id ? series.id : newSeriesId),
                    isIndividual: isIndividual,
                    isPeriodic: series.isPeriodic ? series.isPeriodic : (gUtils.isPeriodic(series.metric) || gUtils.isFinancialQuickMetric(series.metric)),
                    isVisible: series.id ? series.isVisible : true,
                    metric: metric,
                    name: series.name,
                    paneId: series.paneId ? series.paneId : self.currentActivePane().id,
                    periodType: periodType,
                    xAxis: 0,
                    yAxisId: "",
                    currency: currency,
                    isStudy: series.isStudy ? true : false,
                    studyType: series.studyType,
                    studyPeriod: series.studyPeriod,
                    studyStdDev: series.studyStdDev,
                    studySeqId: series.studySeqId,
                    indexDate: series.isStudy && gUtils.isRelativeCapableSiri(series) ? gUtils.getIndexDate(series.id) : null,
                    fontSettings: series.fontSettings ? oc.observable(series.fontSettings) : oc.observable(gUtils.getDefaultFontSettings(gUtils.settingsType.seriesSettings)),
                    offset: offset,
                    orignalData: series.orignalData ? series.orignalData : [],
                    ohlsData: series.ohlsData ? series.ohlsData : [],
                    isCallByTimeframe: series.isCallByTimeframe,
                    currSeriesTimePos: self.globalPos.currTimePos,
                    preservedYAxisObject: series.preservedYAxisObject ? series.preservedYAxisObject : null,
                    deletedCustomKeyIds: series.deletedCustomKeyIds || [],
                    dataLabelsFontSettings: series.dataLabelsFontSettings ? series.dataLabelsFontSettings : gUtils.getDefaultFontSettings(gUtils.settingsType.dataLabelSettings),
                    selectedDataLabelOptions: series.selectedDataLabelOptions ? series.selectedDataLabelOptions : [],
                    keyDevOptions: self.getKeydevOpts(series, defaultKeyDevOpts),
                    isBenchMark: series.isBenchMark || false,
                    benchMarkEntities: series.benchMarkEntities ? series.benchMarkEntities : [],
                    parentSeriesId: series.parentSeriesId,
                    isFrequencyUpdated: false,
                    studySeriesIds: series.studySeriesIds ? series.studySeriesIds : []
                };

                return seriesObject;
            });
            //setting  isReplacedEntity to false as we have already user it
            self.isReplacedEntity = false;

            _.each(seriesCollection, function (series: any) {
                let isPaneExist = false;
                _.each(self.chartBuilderInstance.panes(), function (pane: any) {
                    if (pane.id === series.paneId) {
                        isPaneExist = true;
                    }
                });
                if (!isPaneExist) {
                    let paneCounter = _.filter(self.chartBuilderInstance.panes(), (pane: any) => !pane.isChildPane).length;
                    let newPaneId = series.paneId ? series.paneId : self.getPaneId();
                    let newChartId: any = "mi-stockchart-" + newPaneId;
                    let newPaneName = gUtils.plottedInChildPane(series.studyType) ? formationUtil.getFormattedPaneName(series.entity, series.studyType, series.studyPeriod) : 'Pane ' + (paneCounter + 1);
                    let newPane: CBModels.Pane = {
                        id: newPaneId,
                        name: self.viewContext.observable.observable(newPaneName),
                        isActive: true,
                        yAxisCollection: self.viewContext.observable.observableArray([]) as KnockoutObservableArray<CBModels.Yaxis>,
                        seriesCollection: self.viewContext.observable.observableArray([]) as KnockoutObservableArray<CBModels.Series>,
                        chartId: newChartId,
                        settings: self.viewContext.observable.observable(self.getDefaultSettingsForSideBar()),
                        isChildPane: gUtils.plottedInChildPane(series.studyType) ? true : false,
                        childPaneIds: [],
                        selectedSeriesIds: [],
                        paneKeyDevTypeIds: [],
                        paneKeyDevs: []
                    };
                    self.chartBuilderInstance.panes.push(newPane);
                    //Adding childpanesIds to Parent pane.
                    if (newPane.isChildPane) {
                        let parentSeriesPaneId = _.get(_.find(self.allPanesSeriesArr(), (seri: any) => seri.id === gUtils.getParentSeriesIdByStudySeriesId(series.id)), 'paneId');
                        let parentPane: CBModels.Pane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === parentSeriesPaneId);
                        if (parentPane) {
                            parentPane.childPaneIds.push(newPaneId);
                        }
                    }
                }
            });


            _.each(seriesCollection, function (series: any) {          // To Do: push series Collection
                if (series.studyType === gUtils.StudyType.BB) {
                    series.color = series.color ? series.color : self.getNextAvailableColor(seriesCollection);
                } else {
                    series.color = series.color ? series.color : self.getNextAvailableColor(seriesCollection);
                }
                series.isNew = true;
            });

            self.handleNoDataMessage(seriesCollection);

            var seriesCollectionByPane = _.groupBy(seriesCollection, 'paneId');
            _.each(seriesCollectionByPane, function (seriesCollection: any, key: any) {
                let currentPaneId = parseInt(key);
                //  var targetedPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === seriesCollection[0].paneId; });
                var targetedPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === currentPaneId; });
                _.each(seriesCollection, function (series: any) {
                    var isRequireNewYAxis = yAxisUtil.isRequireNewYAxis(series, targetedPane.yAxisCollection());

                    var plotTotalReturnOnPercentageAxis = false;
                    if (series.metric.key === 290952 && !series.preservedYAxisObject) {
                        _.each(targetedPane.yAxisCollection(), function (yAxis: any) {
                            var nonStudySeries = _.filter(yAxis.seriesIds, function (sid: number) {
                                var srs = _.find(targetedPane.seriesCollection(), function (siri: any) {
                                    return siri.id === sid;
                                });
                                if (!srs) {
                                    srs = _.find(seriesCollection, function (siri: any) {
                                        return siri.id === sid;
                                    });
                                }
                                return !srs.isStudy && gUtils.isRelativeCapableSiri(srs);
                            });

                            if ((yAxis.id.split("_")[0] === "($)" && nonStudySeries.length > 1 && yAxis.valueScale.type !== "absolute") || yAxis.valueScale.type === "relative") {
                                plotTotalReturnOnPercentageAxis = true;
                                isRequireNewYAxis = false;
                            }
                        });
                    }

                    if (isRequireNewYAxis) {
                        var newYAxis = yAxisUtil.generateYAxis(series, targetedPane.yAxisCollection(), self.globalRelativity());
                        newYAxis.seriesIds.push(series.id);
                        series.yAxis = newYAxis.id;
                        targetedPane.yAxisCollection.push(newYAxis);
                    }
                    else {
                        var targetedYAxisObject: any;
                        _.each(targetedPane.yAxisCollection(), function (yAxis: any) {
                            var nonStudySeries = _.filter(yAxis.seriesIds, function (sid: number) {
                                var srs = _.find(targetedPane.seriesCollection(), function (siri: any) {
                                    return siri.id === sid;
                                });
                                if (!srs) {
                                    srs = _.find(seriesCollection, function (siri: any) {
                                        return siri.id === sid;
                                    });
                                }
                                return !srs.isStudy && gUtils.isRelativeCapableSiri(srs);
                            });
                            if ((yAxis.id.split("_")[0] === series.metric.defaultMagnitude && !plotTotalReturnOnPercentageAxis) || (plotTotalReturnOnPercentageAxis && ((yAxis.id.split("_")[0] === "($)" && nonStudySeries.length > 1 && yAxis.valueScale.type !== "absolute") || yAxis.valueScale.type === "relative"))) {
                                targetedYAxisObject = yAxis;
                            }
                        });

                        if (series.preservedYAxisObject) {
                            targetedYAxisObject = _.find(targetedPane.yAxisCollection(), function (yAxis: any) {
                                return yAxis.id === series.preservedYAxisObject.id;
                            });
                        }

                        if (series.isStudy) {
                            if (targetedPane.isChildPane) {
                                targetedYAxisObject = _.find(targetedPane.yAxisCollection(), function (yAxis: any) {
                                    return _.find(yAxis.seriesIds, function (seriesId: number) {
                                        //  return Math.floor(seriesId) === Math.floor(series.id);
                                        return gUtils.getParentSeriesIdByStudySeriesId(seriesId) === gUtils.getParentSeriesIdByStudySeriesId(series.id);
                                    });
                                });
                            }
                            else {
                                targetedYAxisObject = _.find(targetedPane.yAxisCollection(), function (yAxis: any) {
                                    return _.find(yAxis.seriesIds, function (seriesId: number) {
                                        return seriesId === gUtils.getParentSeriesIdByStudySeriesId(series.id);
                                    });
                                });
                            }
                        }

                        if (targetedYAxisObject) {
                            targetedYAxisObject.seriesIds.push(series.id);
                            series.yAxis = targetedYAxisObject.id;
                        }
                        //Move existing Total return to targeted Yaxis
                        if (plotTotalReturnOnPercentageAxis) {
                            gUtils.moveTotalReturnToPercentageAxis(self.view, targetedPane, targetedYAxisObject);
                            yAxisUtil.removeYAxisHack();
                        }
                        else {
                            var nonStudySeries = _.filter(targetedYAxisObject.seriesIds, function (sid: number) {
                                var srs = _.find(targetedPane.seriesCollection(), function (siri: any) {
                                    return siri.id === sid;
                                });
                                if (!srs) {
                                    srs = _.find(seriesCollection, function (siri: any) {
                                        return siri.id === sid;
                                    });
                                }
                                return !srs.isStudy && gUtils.isRelativeCapableSiri(srs);
                            });
                            if ((targetedYAxisObject.id.split("_")[0] === "($)" && nonStudySeries.length > 1 && targetedYAxisObject.valueScale.type !== "absolute") || targetedYAxisObject.valueScale.type === "relative") {
                                let isRelativeYAxisExists = false;
                                if (currChart) {
                                    _.each(currChart.yAxis, function (hyAxis: any) {
                                        if (targetedYAxisObject.id === hyAxis.userOptions.id) {
                                            isRelativeYAxisExists = true;
                                        }
                                    });
                                }
                                if (series.isBenchMark) {
                                    isRelativeYAxisExists = false;
                                }


                                if (isRelativeYAxisExists) {
                                    var newTotalReturnSeriesIds = gUtils.moveTotalReturnToPercentageAxis(self.view, targetedPane, targetedYAxisObject);
                                    yAxisUtil.removeYAxisHack();
                                    if (newTotalReturnSeriesIds.length > 0) {
                                        _.each(newTotalReturnSeriesIds, function (sid) {
                                            var uintse = _.find(seriesCollection, function (uis: any) {
                                                return uis.id === sid;
                                            });
                                            if (uintse) {
                                                uintse.yAxis = targetedYAxisObject.id;
                                                targetedYAxisObject.seriesIds.push(uintse.id);
                                            }
                                        });
                                    }
                                }
                                else {
                                    if (currChart) {
                                        var parentSeries = currChart.series.filter(function (seri: any) {
                                            return seri.userOptions.type !== 'flags' && !seri.isStudy && !seri.isBenchMark;
                                        });
                                        _.each(parentSeries, function (hs) {
                                            if (hs.userOptions.yAxis.split("_")[0] === "%" && hs.userOptions.metric.key === 290952 && hs.yAxis.series.length > 1) {

                                                var uiTotalReturnAxis = _.find(targetedPane.yAxisCollection(), function (uiy: any) {
                                                    return uiy.id === hs.yAxis.userOptions.id;
                                                });
                                                uiTotalReturnAxis.id = targetedYAxisObject.id;

                                                var uits = _.find(targetedPane.seriesCollection(), function (uis: any) {
                                                    return uis.yAxis === hs.userOptions.yAxis;
                                                });
                                                uits.yAxis = targetedYAxisObject.id;
                                                hs.yAxis.userOptions.id = targetedYAxisObject.id;
                                                hs.yAxis.update({ yAxis: targetedYAxisObject.id });
                                                hs.userOptions.yAxis = targetedYAxisObject.id;
                                                _.each(targetedYAxisObject.seriesIds, function (usid) {
                                                    var uinse = _.find(seriesCollection, function (uis: any) {
                                                        return uis.id === usid;
                                                    });


                                                    if (uinse && uiTotalReturnAxis.seriesIds.indexOf(uinse.id) === -1) {
                                                        uiTotalReturnAxis.seriesIds.push(uinse.id);
                                                        uinse.yAxis = uiTotalReturnAxis.id;
                                                    }
                                                    var uiese = _.find(targetedPane.seriesCollection(), function (uis: any) {
                                                        return uis.id === usid;
                                                    });

                                                    if (uiese && uiTotalReturnAxis.seriesIds.indexOf(uiese.id) === -1) {
                                                        uiTotalReturnAxis.seriesIds.push(uiese.id);
                                                        uiese.yAxis = uiTotalReturnAxis.id;
                                                        var hese: any = _.find(parentSeries, function (cs: any) {
                                                            return cs.userOptions.id === uiese.id;
                                                        });
                                                        if (hese) {
                                                            var cheseHAxis = hese.yAxis;
                                                            hese.update({ yAxis: uiTotalReturnAxis.id });
                                                            if (cheseHAxis.series.length === 0) {
                                                                cheseHAxis.remove();
                                                            }
                                                        }
                                                    }

                                                });

                                                targetedPane.yAxisCollection.remove(targetedYAxisObject);
                                            }
                                        });
                                    }
                                }

                            }
                        }
                    }
                });

                _.each(seriesCollection, function (series: any) {
                    if (series.preservedYAxisObject) {
                        delete series.preservedYAxisObject;
                    }
                });

                ko.utils.arrayPushAll(targetedPane.seriesCollection, seriesCollection);
                self.hasTotalReturn(self.checkTotalReturnwithIndices(targetedPane.seriesCollection()));

                // Once all entities removed and then on adding new entity all subscribers dont get notified.
                // Actual root cause needs to be found
                // Bug# 1594425, 1594503, 1608586
                if (_.any(seriesCollection)) {
                    self.firstPaneSeriesArr.notifySubscribers(self.firstPaneSeriesArr());
                    self.allPanesSeriesArr.notifySubscribers(self.allPanesSeriesArr());
                }
            });

            //#endregion
            self.adjustStartDate();

            //Calling the chart changed Callback for each modified pane
            var panesToRefresh: number[] = [];

            _.each(seriesCollection, function (series: any) {
                if (series.isStudy) {
                    panesToRefresh.push(series.paneId);
                }
                else {
                    panesToRefresh.push(1);
                }
            });

            panesToRefresh = _.uniq(panesToRefresh);

            _.each(panesToRefresh, (paneId: number) => {
                self.chartChangedCB(paneId);
            });

        };

        self.checkTotalReturnwithIndices = function (seriesCollection: any) {
            if (_.some(seriesCollection, function (item: any) { return ((item.metric.key === 290952 || item.metric.key === 318951) && item.entity.contentSet === 6); })) {
                return true;
            } else {
                return false;
            }
        };
        //#endregion

        //#region Remove Series
        self.removeTargetSeriesCollectionByElement = function (collection: any, context: any) {
            var targetSeriesCollection: Array<any> = [];
            _.each(collection, function (item: any) {
                ko.utils.arrayPushAll(targetSeriesCollection, context === "entity" ? gUtils.findSeriesByEntity(gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()), item) : gUtils.findSeriesByMetric(gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()), item));
            });
            let childPaneSeriesCollection: Array<any> = [];
            //get child pane series related to targeted parent series
            _.each(targetSeriesCollection, function (series: any) {
                if (!series.isStudy) {
                    ko.utils.arrayPushAll(childPaneSeriesCollection, gUtils.findChildSeriesByParent(gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()), series.id));
                }
            });
            targetSeriesCollection = _.union(targetSeriesCollection, childPaneSeriesCollection);
            self.removeSeries(targetSeriesCollection, false, context === "metric");
            self.chartChangedCB();
        };

        self.removeSeries = function (seriesCollection: any, shouldRemoveEntity?: boolean, shouldRemoveMetrics?: boolean) {         // To DO : refactor this code
            let targetSeriesIds: number[] = [];
            let studySeriesIds: number[] = [];
            if ((seriesCollection) && (seriesCollection.length > 0 || seriesCollection.isStudy)) {
                targetSeriesIds = _.map(seriesCollection, function (series: any) {
                    return series.id;
                });
                studySeriesIds = _.pluck(_.flatten(_.filter(_.pluck(seriesCollection, 'participants'), function (series: any) {
                    return series && series.length > 0;
                })), 'id');
            }
            let targetedSeriesIds = _.union(targetSeriesIds, studySeriesIds);
            let targetedSeriesCollection = _.filter(self.allPanesSeriesArr(), (s: any) => _.contains(targetedSeriesIds, s.id));
            let seriesCollectionByPane = _.groupBy(targetedSeriesCollection, 'paneId');
            _.each(seriesCollectionByPane, function (targetSeriesCollection: any, key: any) {
                let targetIds = _.pluck(targetSeriesCollection, 'id');
                let currentPaneId = parseInt(key);
                let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === currentPaneId; });
                //#region - getting hidden(in seriesmanager grid) bollinger bands series ids to remove from chart
                var seriesCollection = currentPane.seriesCollection;
                var targetedStudyWithMultiSeries = _.filter(targetSeriesCollection, function (series: any) {
                    // return series.isStudy && (series.studyType === gUtils.StudyType.BB || series.studyType === gUtils.StudyType.MACD);
                    return series.isStudy && gUtils.hasMultipeStudySeries(series.studyType);
                });
                var selectedStudyWithMultiSeries = _.filter(_.flatten(_.filter(_.pluck(targetSeriesCollection, 'participants'), function (series: any) {
                    return series && series.length > 0;
                })), function (series: any) { return gUtils.hasMultipeStudySeries(series.studyType); });
                var seriesSelected = _.union(targetedStudyWithMultiSeries, selectedStudyWithMultiSeries);
                _.each(seriesSelected, function (selectedStudySeries: any) {
                    let hiddenStudySeriesIds = [];
                    if (gUtils.hasMultipeStudySeries(selectedStudySeries.studyType)) {
                        hiddenStudySeriesIds = _.pluck(_.filter(seriesCollection(), function (series: any) {
                            let studyParentId = null;
                            if (series.isStudy && series.studyType === selectedStudySeries.studyType) {
                                studyParentId = gUtils.getParentSeriesIdByStudySeriesId(series.id);
                            }
                            return selectedStudySeries.studyType === gUtils.StudyType.MACD ? studyParentId === selectedStudySeries.parentSeriesId && series.studySeqId !== 0 :
                                studyParentId === selectedStudySeries.parentSeriesId && series.studySeqId !== 0 && series.studyPeriod === selectedStudySeries.studyPeriod && series.studyStdDev === selectedStudySeries.studyStdDev;
                        }), 'id');
                    }
                    targetIds = _.union(targetIds, hiddenStudySeriesIds);
                });
                //#endegion

                //Removing study series ids from parent series 
                let studyIds: number[] = _.pluck(_.filter(self.allPanesSeriesArr(), function (s: any) {
                    return s.isStudy && _.contains(targetIds, s.id);
                }), 'id');

                _.each(self.allPanesSeriesArr(), (s: any) => {
                    if (!s.isStudy) {
                        _.each(studyIds, (studyId: any) => {
                            _.remove(s.studySeriesIds, (id: number) => id === studyId);
                        });
                    }
                });

                self.removeHighchartSeries(targetIds, currentPaneId);
                //  let currentPaneId = (seriespaneId.length > 1) ? 1 : seriespaneId[0];
                var targetedPaneSeriesCollection = currentPane ? currentPane.seriesCollection : oc.observableArray([]);
                var targetPaneYAxisCollection = currentPane ? currentPane.yAxisCollection : oc.observableArray([]);

                //#region wipe out series and axis mapping    : To Do : Remove this code
                var percentageCapableYaxis: any;
                _.each(targetSeriesCollection, function (series: any) {
                    var targetYAxisObject = gUtils.findYAxisObjectbyId(targetPaneYAxisCollection(), series.yAxis);
                    if ((!targetYAxisObject) && (series.axis) && (series.axis.yAxis)) {      // To Do : Remove this : Adding fix for series manager: remove all
                        targetYAxisObject = gUtils.findYAxisObjectbyId(targetPaneYAxisCollection(), series.axis.yAxis);
                    }
                    if (targetYAxisObject) {
                        targetYAxisObject.seriesIds = _.remove(targetYAxisObject.seriesIds, function (id: any) {
                            return id !== series.id && Math.floor(id) !== series.id; //removing studies along with parent series
                        });

                        if (targetYAxisObject.id.split("_")[0] === "($)") {
                            percentageCapableYaxis = targetYAxisObject;
                        }
                    }
                });

                var currentHighChart = gUtils.findHighchartById(self.view, _.get(currentPane, 'chartId'));

                if (percentageCapableYaxis) {
                    var noOfTotalReturnSeries: any[] = [];

                    _.each(percentageCapableYaxis.seriesIds, function (sid) {
                        var axisSeries = _.find(targetedPaneSeriesCollection(), function (tpSeries: any) {
                            return sid === tpSeries.id;
                        });

                        if (axisSeries && axisSeries.metric.key === 290952) {
                            noOfTotalReturnSeries.push(axisSeries);
                        }
                    });

                    var newHS: any;
                    var seriesthWithouthStudy = percentageCapableYaxis.seriesIds.filter(function (s: any) { return parseInt(s) === s; });
                    if (noOfTotalReturnSeries.length > 0 && seriesthWithouthStudy.length - noOfTotalReturnSeries.length < 2) {
                        var newYAxis = yAxisUtil.generateYAxis(noOfTotalReturnSeries[0], targetPaneYAxisCollection(), self.globalRelativity());


                        _.each(noOfTotalReturnSeries, function (series) {
                            newYAxis.seriesIds.push(series.id);
                            series.yAxis = newYAxis.id;
                            percentageCapableYaxis.seriesIds = _.remove(percentageCapableYaxis.seriesIds, function (id: any) {
                                return id !== series.id;
                            });
                        });
                        currentPane.yAxisCollection.push(newYAxis);
                        yAxisUtil.removeYAxisHack();
                        currentHighChart.addAxis(newYAxis);

                        _.each(newYAxis.seriesIds, function (sid) {
                            newHS = _.find(currentHighChart.series, function (chs: any) {
                                return chs.userOptions.id === sid;

                            });
                            if (newHS) {
                                newHS.update({ yAxis: newYAxis.id });
                            }
                        });
                    }

                    if (percentageCapableYaxis.seriesIds.length === 0) {
                        var highchartAxis: any;
                        if (currentHighChart) {
                            _.each(currentHighChart.yAxis, function (hyAxis: any) {
                                if (percentageCapableYaxis.id === hyAxis.userOptions.id) {
                                    highchartAxis = hyAxis;
                                }
                            });
                            if (highchartAxis) {
                                highchartAxis.remove();
                                yAxisUtil.removeYAxisHack();
                            }
                            currentPane.yAxisCollection.remove(percentageCapableYaxis);
                            if (newHS && currentHighChart.yAxis.length === 1) {
                                newHS.yAxis.update({ opposite: false });
                            }
                            else {
                                currentHighChart.yAxis[0].update({ opposite: false });
                            }
                        }
                    }
                }

                targetPaneYAxisCollection.remove(function (yAxis: any) {
                    return yAxis.seriesIds.length === 0;
                });
                //#endegion

                targetedPaneSeriesCollection.remove(function (series: any) {
                    return _.contains(targetIds, series.id);
                });

                self.hasTotalReturn(self.checkTotalReturnwithIndices(targetedPaneSeriesCollection()));



                self.actualData.remove(function (seriesData: any) {
                    return _.contains(targetIds, seriesData.id);
                });

                if (currentPaneId === 1 && currentPane.seriesCollection().length === 0) {// added condition due to validation if it Parent pane
                    var currentChart = gUtils.findHighchartById(self.view, _.get(currentPane, 'chartId'));
                    currentChart.yAxis[0].setExtremes(0, 100);
                }
                //This is a hack to fix Secondary Y-Axis label overlapping issue
                if (currentHighChart && currentHighChart.yAxis.length > 1) {
                    for (let yx of currentHighChart.yAxis) {
                        if (yx !== currentHighChart.yAxis[0]) {
                            yx.update({ labels: { align: 'center' } });
                        }
                    }
                }

                //Removing pane and high chart
                let isRemovePane = currentPane.seriesCollection().length === 0;
                if (isRemovePane) {
                    if (currentPaneId === 1 && currentPane.childPaneIds.length > 0) {
                        _.each(currentPane.childPaneIds, (childPaneId: number) => {
                            let paneIndex = _.findIndex(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === childPaneId; });
                            self.removeHighChart(paneIndex);
                            self.removePane(childPaneId);
                        });
                    }
                    else {
                        let paneIndex = _.findIndex(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === currentPane.id; });
                        self.removeHighChart(paneIndex);
                        self.removePane(currentPane.id);
                    }
                }
            });

            self.chartChangedCB();
            // Remove Metrics Logic
            // it has to be executed only on direct deleting of Metrics
            if (shouldRemoveMetrics) {
                self.chartBuilderInstance.metrics.remove(function (metric: any) {
                    return !_.contains(_.pluck(_.where(gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()), { entity: { isStaticEntity: false } }), 'metric.keyItem'), metric.keyItem);
                });
            }
            // Remove Entity Logic
            if (shouldRemoveEntity) {
                self.chartBuilderInstance.entities.remove(function (entity: any) {
                    return !_.contains(_.pluck(_.where(gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()), { entity: { isStaticEntity: false } }), 'entity.companySnlKeyInstn'), entity.companySnlKeyInstn);
                });

                if ((self.chartBuilderInstance.entities().length === 0) && (self.entitySelectedValue().length > 0)) {    // Series Manager: remove all
                    self.entitySelectedValue([]);
                }
            }

            //self.firstPaneSeriesArr.notifySubscribers(self.firstPaneSeriesArr());
            self.allPanesSeriesArr.notifySubscribers(self.allPanesSeriesArr());
            self.refreshChartSummary(true);
        };

        self.getJSDateFromYYYYMMDD = function (input: any) {
            var inputString = "" + input;
            var year = parseInt(inputString.substring(0, 4));
            var month = parseInt(inputString.substring(4, 6));
            var date = parseInt(inputString.substring(6, 8));

            return new Date(year, month - 1, date);
        };

        self.generateDummyData = function (startDate: any, endDate: any) {
            var start = self.getJSDateFromYYYYMMDD(startDate);
            var end = self.getJSDateFromYYYYMMDD(endDate);

            var current = start;
            var data = [];
            while (current <= end) {
                data.push([current.getTime(), null]);
                current.setDate(current.getDate() + 1);
            }

            return data;
        };
        //isResetChartBuilderCall is a flag to check if it is a call with observable values or non -observable values
        self.updateHighchartLabels = function (pane: any, isOfficeExportUpdate: boolean = false, isResetChartBuilderCall: boolean = false) {
            if (pane) {
                if (!isResetChartBuilderCall) {
                    self.updateChartTitle(pane.settings().titleFontSettings(), true, false, pane.id, isOfficeExportUpdate);
                    self.updateChartSubTitle(pane.settings().subTitleFontSettings(), true, false, pane.id, isOfficeExportUpdate);
                    self.updateChartXAxisLabel(pane.settings().xAxisFontSettings(), true, false, pane.id, isOfficeExportUpdate);
                    self.updateXAxisFont(pane.settings().xAxisLabelFontSettings(), true, false, pane.id);
                    self.updateChartLegendName(pane.settings().legendFontSettings(), true, false, pane.id);
                    self.updateYAxisGridLines(pane.settings().gridLinesEnabled());
                }
                else {
                    self.updateChartTitle(pane.settings.titleFontSettings, true, false, pane.id, isOfficeExportUpdate);
                    self.updateChartSubTitle(pane.settings.subTitleFontSettings, true, false, pane.id, isOfficeExportUpdate);
                    self.updateChartXAxisLabel(pane.settings.xAxisFontSettings, true, false, pane.id, isOfficeExportUpdate);
                    self.updateXAxisFont(pane.settings.xAxisLabelFontSettings, true, false, pane.id);
                    self.updateChartLegendName(pane.settings.legendFontSettings, true, false, pane.id);
                    self.updateYAxisGridLines(pane.settings.gridLinesEnabled);
                }
            }
        };

        self.redrawChart = function (paneId: number = 1) {
            let currChart = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[paneId - 1], 'chartId'));
            if (currChart) {
                currChart.redraw();
            }
        };

        self.getFormattedDateForSingleDigitMonth = function (value: string) {
            var formattedValue: any;
            formattedValue = window.Highcharts.dateFormat('%m', value as any);
            if (!isNaN(formattedValue)) {
                //This is to avoid substring for values greater than 9 because month should not show prefix 0 for single digit month
                //Refer comment section of Bug 2035582: Office Tools:-[Charting]:-The custom options are not showing as per user's selection on x axis lable for more clarification
                if (formattedValue < 10) {
                    return (formattedValue.substring(1, 2));
                }
                else {
                    return formattedValue;
                }
            }
            else {
                return formattedValue;
            }
        };

        self.updateChartTitle = function (titleObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number, isOfficeExportUpdate: boolean) {
            let xSpace = 0;
            if (titleObj.horizontalAlign === 'center') {
                xSpace = 17;
            }
            var title = {
                text: titleObj.text,
                useHTML: true,
                verticalAlign: titleObj.verticalAlign,
                x: xSpace,
                y: 24,
                align: titleObj.horizontalAlign,
                style: {
                    fontSize: titleObj.fontSize + 'px',
                    fontFamily: titleObj.fontFamily,
                    fontWeight: titleObj.isBold ? "bold" : "normal",
                    fontStyle: titleObj.isItalic ? 'italic' : 'normal',
                    textDecoration: titleObj.isUnderline ? 'underline' : 'none',
                    color: titleObj.fontColor
                }
            };
            self.adjustTitleOrSubTitleorLegendPositions(title, chartCustomizationAction.updateTitle, isRedraw, titleObj, isGlobalUpdate, paneId, isOfficeExportUpdate);
        };

        self.updateChartSubTitle = function (subTitleObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number, isOfficeExportUpdate: boolean) {
            self.isSubTitleAtBottomRight(false);
            let xSpace = 0;
            if (subTitleObj.horizontalAlign === 'center') {
                xSpace = 17;
            }
            let subtitle = {
                text: subTitleObj.text,
                useHTML: true,
                verticalAlign: subTitleObj.verticalAlign,
                x: xSpace,
                y: 47,
                margin: 10,
                align: subTitleObj.horizontalAlign,
                style: {
                    fontSize: subTitleObj.fontSize + 'px',
                    fontFamily: subTitleObj.fontFamily,
                    fontWeight: subTitleObj.isBold ? "bold" : "normal",
                    fontStyle: subTitleObj.isItalic ? 'italic' : 'normal',
                    textDecoration: subTitleObj.isUnderline ? 'underline' : 'none',
                    color: subTitleObj.fontColor
                }
            };
            self.adjustTitleOrSubTitleorLegendPositions(subtitle, chartCustomizationAction.updateSubTitle, isRedraw, subTitleObj, isGlobalUpdate, paneId, isOfficeExportUpdate);
        };

        // Apply the grid lines enabled setting to each y-axis to reflect grid lines for entire chart.
        self.updateYAxisGridLines = function (isGridLines: boolean, isRedraw: boolean = false, paneId: number = 1) {
            if (self.isOffice()) {
                for (var i = 0; i < self.chartBuilderInstance.panes().length; i++) {
                    self.updateSingleChartYAxisGridlines(_.get(self.chartBuilderInstance.panes()[i], 'id'), isGridLines, isRedraw);
                }
            }
            else {
                self.updateSingleChartYAxisGridlines(paneId, isGridLines, isRedraw);
            }
        };

        self.updateChartLegendName = function (legendObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number = 1) {
            let currPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
            var currChart = gUtils.findHighchartById(self.view, _.get(currPane, 'chartId'));
            var legendXPosition = 28;
            var legendItemDistance = 30;
            if (legendObj.horizontalAlign === 'right') {
                legendXPosition = -10;
            }
            if (legendObj.fontFamily === "Courier New") {
                legendItemDistance = 60;
            }
            let legend = {
                useHTML: true,
                align: legendObj.horizontalAlign,
                x: legendXPosition,
                itemDistance: legendItemDistance,
                itemStyle: {
                    fontSize: legendObj.fontSize + 'px',
                    fontFamily: legendObj.fontFamily,
                    fontWeight: legendObj.isBold ? "bold" : "normal",
                    fontStyle: legendObj.isItalic ? 'italic' : 'normal',
                    textDecoration: legendObj.isUnderline ? 'underline' : 'none',
                    color: legendObj.fontColor
                }
            };
            if (isGlobalUpdate) {
                if (self.isOffice()) {
                    for (var i = 0; i < self.chartBuilderInstance.panes().length; i++) {
                        let currChart = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[i], 'chartId'));
                        currChart.update({ legend });
                        self.chartBuilderInstance.panes()[i].settings().legendFontSettings(legendObj);
                    }
                }
                else {
                    currChart.update({ legend });
                    self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1].settings().legendFontSettings(legendObj);
                }
            }
            else {
                if (currChart) {
                    if (isRedraw) {
                        currChart.update({ legend });
                    }
                    else {
                        currChart.update({ legend }, false);
                    }
                }
            }
        };

        self.updateXAxisFont = function (xAxisObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number = 1) {
            let currPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
            var currChart = gUtils.findHighchartById(self.view, _.get(currPane, 'chartId'));
            var dateFormat = CBModels.makeDefaultDateFormat();
            if (xAxisObj.dateFormat) {
                dateFormat = xAxisObj.dateFormat;
            }
            var fontStyles = {
                fontSize: xAxisObj.fontSize + 'px',
                fontFamily: xAxisObj.fontFamily,
                fontWeight: xAxisObj.isBold ? "bold" : "normal",
                fontStyle: xAxisObj.isItalic ? 'italic' : 'normal',
                textDecoration: xAxisObj.isUnderline ? 'underline' : 'none',
                color: xAxisObj.fontColor
            };
            var xAxisLabelSettings = {
                xAxis: {
                    labels: {
                        useHTML: true,
                        formatter: function (): any {
                            var current: any = this;
                            if (dateFormat) {
                                if (dateFormat.dateFormat === webStrings.chartBuilderXAxisCustomDateCustomDropDownText()) {
                                    var firstStr, secondStr, thirdStr;
                                    if (dateFormat.firstFormatter === webStrings.chartBuilderXAxisCustomMonthText()) {
                                        firstStr = self.getFormattedDateForSingleDigitMonth(current.value);
                                    }
                                    else {
                                        firstStr = window.Highcharts.dateFormat(dateFormat.firstFormatter, current.value);
                                    }
                                    if (dateFormat.secondFormatter === webStrings.chartBuilderXAxisCustomMonthText()) {
                                        secondStr = self.getFormattedDateForSingleDigitMonth(current.value);
                                    }
                                    else {
                                        secondStr = window.Highcharts.dateFormat(dateFormat.secondFormatter, current.value);
                                    }
                                    if (dateFormat.thirdFormatter === webStrings.chartBuilderXAxisCustomMonthText()) {
                                        thirdStr = secondStr = self.getFormattedDateForSingleDigitMonth(current.value);
                                    }
                                    else {
                                        thirdStr = window.Highcharts.dateFormat(dateFormat.thirdFormatter, current.value);
                                    }
                                    var formattedDate = firstStr + dateFormat.delimeter1 + secondStr + dateFormat.delimeter2 + thirdStr;
                                    return formattedDate;
                                }
                                else {
                                    var formattedDateFormat;

                                    if (dateFormat.dateFormat === "") {
                                        formattedDateFormat = window.Highcharts.dateFormat("%b'%y", current.value);
                                    }
                                    else {

                                        formattedDateFormat = window.Highcharts.dateFormat(dateFormat.dateFormat, current.value);
                                    }

                                    return formattedDateFormat;
                                }
                            }
                            else {
                                var formattedDateFormatForOldCharts;
                                formattedDateFormatForOldCharts = window.Highcharts.dateFormat("%b'%y", current.value);
                                return formattedDateFormatForOldCharts;
                            }

                        },
                        style: fontStyles
                    }
                }
            };
            //Checks if default is selected or if it is initial sidebar load
            if (xAxisObj.dateFormat.dateFormat === webStrings.chartingSettingsSidebarXAxisDefaultText() || xAxisObj.dateFormat.dateFormat === "") {
                //Deletes the formatter if it is initial load or selected dateformat is default
                delete xAxisLabelSettings.xAxis.labels.formatter;
                //Checks if current chart has the formatter and then deletes it
                if (_.get(currChart, 'options.xAxis[0].labels.formatter')) {
                    delete currChart.options.xAxis[0].labels.formatter;
                }
            }
            if (isGlobalUpdate) {
                if (self.isOffice()) {
                    for (var i = 0; i < self.chartBuilderInstance.panes().length; i++) {
                        let currChart = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[i], 'chartId'));
                        currChart.update(xAxisLabelSettings);
                        self.chartBuilderInstance.panes()[i].settings().xAxisLabelFontSettings(xAxisObj);
                    }
                }
                else {
                    let currChart = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1], 'chartId'));
                    currChart.update(xAxisLabelSettings);
                    self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1].settings().xAxisLabelFontSettings(xAxisObj);
                }
            }
            else {
                if (currChart) {
                    if (isRedraw) {
                        currChart.update(xAxisLabelSettings);
                    }
                    else {
                        currChart.update(xAxisLabelSettings, false);
                    }
                }
            }

        };



        self.updateChartXAxisLabel = function (xAxisLabelObj: any, isRedraw: boolean, isGlobalUpdate: boolean, paneId: number = 1, isOfficeExportUpdate: boolean) {
            let currPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
            var currChart = gUtils.findHighchartById(self.view, _.get(currPane, 'chartId'));
            var xAxis = {
                xAxis: {
                    title: {
                        text: xAxisLabelObj.text,
                        useHTML: true,
                        style: {
                            fontSize: xAxisLabelObj.fontSize + 'px',
                            fontFamily: xAxisLabelObj.fontFamily,
                            fontWeight: xAxisLabelObj.isBold ? "bold" : "normal",
                            fontStyle: xAxisLabelObj.isItalic ? 'italic' : 'normal',
                            textDecoration: xAxisLabelObj.isUnderline ? 'underline' : 'none',
                            color: xAxisLabelObj.fontColor
                        },
                        y: xAxisLabelObj.rotate ? -10 : 0,
                        rotation: xAxisLabelObj.rotate ? 180 : 0
                    }
                }
            };
            if (isOfficeExportUpdate) {
                let currentPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
                if (currentPane.isChildPane) {
                    delete xAxis.xAxis.title.text;
                }
            }
            if (isGlobalUpdate) {
                if (self.isOffice()) {
                    for (var i = 0; i < self.chartBuilderInstance.panes().length; i++) {
                        let currChart = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[i], 'chartId'));
                        if (self.chartBuilderInstance.panes()[i].isChildPane) {
                            delete xAxis.xAxis.title.text;
                        }
                        currChart.update(xAxis);
                        self.chartBuilderInstance.panes()[i].settings().xAxisFontSettings(xAxisLabelObj);
                    }
                }
                else {
                    let currChart = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1], 'chartId'));
                    if (self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1].isChildPane) {
                        delete xAxis.xAxis.title.text;
                    }
                    currChart.update(xAxis);
                    self.chartBuilderInstance.panes()[self.sidebarSelectedPaneId() - 1].settings().xAxisFontSettings(xAxisLabelObj);
                }
            }
            else if (currChart) {
                if (isRedraw) {
                    currChart.update(xAxis);
                }
                else {
                    currChart.update(xAxis, false);
                }
            }
        };
        //This method gets called whenever there is an update in chart title or subtitle or legend , the purpose of this method is to calculate the position
        // of title or subtitle or legend and adjust the spacing between each of them.
        self.adjustTitleOrSubTitleorLegendPositions = function (updateObject: any, action: any, isRedraw: boolean, updateObjectSettings: any, isGlobalUpdate: boolean = false, paneId: number = 1, isOfficeExportUpdate: boolean) {
            var isRedrawLocal = isRedraw;
            if (isRedrawLocal === undefined) {
                isRedrawLocal = true;
            }
            let currPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
            let currChart = gUtils.findHighchartById(self.view, _.get(currPane, 'chartId'));
            let legendY = 0;
            let title, subtitle, legend;
            let isChartTitleAvailable, isChartSubTitleAvailable, isChartLegendAvailable, isChartSubTitleVerticallyAlignedAtTop, isChartTitleVerticallyAlignedAtTop: boolean;
            if (currChart) {
                isChartTitleAvailable = gUtils.isChartTitleAvailable(currChart);
                isChartTitleVerticallyAlignedAtTop = _.get(currChart, 'title.alignOptions.verticalAlign') !== 'bottom';
                isChartSubTitleAvailable = gUtils.isChartSubTitleAvailable(currChart);
                isChartSubTitleVerticallyAlignedAtTop = _.get(currChart, 'subtitle.alignOptions.verticalAlign') !== 'bottom';
                isChartLegendAvailable = gUtils.isChartLegendAvailable(currChart);
                title = {
                    margin: 10
                };
                switch (action) {
                    case chartCustomizationAction.updateTitle:
                        isChartTitleAvailable = (_.get(updateObject as any, 'text.length') as number) > 0;
                        isChartTitleVerticallyAlignedAtTop = _.get(updateObject, 'verticalAlign') !== 'bottom';
                        title = updateObject;
                        break;
                    case chartCustomizationAction.updateSubTitle:
                        isChartSubTitleAvailable = (_.get(updateObject as any, 'text.length') as number) > 0;
                        isChartSubTitleVerticallyAlignedAtTop = _.get(updateObject, 'verticalAlign') !== 'bottom';
                        if (!isChartSubTitleVerticallyAlignedAtTop) {
                            self.isSubTitleAtBottomRight(true);
                        }
                        subtitle = updateObject;
                        break;
                }
                //title , SubTitle , legend all are available at top
                if (isChartTitleAvailable && isChartTitleVerticallyAlignedAtTop && isChartSubTitleAvailable && isChartSubTitleVerticallyAlignedAtTop) {
                    legendY = 18;
                    title.margin = 35;
                }
                //title is available at top, SubTitle is either not available or at bottom, legend not available
                else if ((isChartTitleAvailable && isChartTitleVerticallyAlignedAtTop)
                    && ((isChartSubTitleAvailable && !isChartSubTitleVerticallyAlignedAtTop) || !isChartSubTitleAvailable) && !isChartLegendAvailable) {
                    legendY = 18;
                    title.margin = 10;
                }
                //title is either not available or at bottom, SubTitle is available at top, legend not available
                else if (((isChartTitleAvailable && !isChartTitleVerticallyAlignedAtTop) || !isChartTitleAvailable)
                    && (isChartSubTitleAvailable && isChartSubTitleVerticallyAlignedAtTop) && !isChartLegendAvailable) {
                    legendY = 18;
                    title.margin = 35;
                }
                //title is available at top, SubTitle is either not available or at bottom, legend available
                else if ((isChartTitleAvailable && isChartTitleVerticallyAlignedAtTop)
                    && ((isChartSubTitleAvailable && !isChartSubTitleVerticallyAlignedAtTop) || !isChartSubTitleAvailable) && isChartLegendAvailable) {
                    legendY = 18;
                    title.margin = 10;
                }
                //title is either not available or at bottom, SubTitle available at top, legend available
                else if (((isChartTitleAvailable && !isChartTitleVerticallyAlignedAtTop) || !isChartTitleAvailable)
                    && (isChartSubTitleAvailable && isChartSubTitleVerticallyAlignedAtTop) && isChartLegendAvailable) {
                    legendY = 10;
                    title.margin = 35;
                }
                //title is either not available or at bottom, SubTitle is either not available or at bottom, legend available
                else if (((isChartTitleAvailable && !isChartTitleVerticallyAlignedAtTop) || !isChartTitleAvailable)
                    && ((isChartSubTitleAvailable && !isChartSubTitleVerticallyAlignedAtTop) || !isChartSubTitleAvailable)
                    && isChartLegendAvailable) {
                    legendY = 5;
                    title.margin = 0;
                }
                legend = {
                    y: legendY
                };
                if (isOfficeExportUpdate) {
                    let currPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
                    if (currPane.isChildPane) {
                        if (action === chartCustomizationAction.updateSubTitle) {
                            subtitle.margin = 0;
                            subtitle.y = 0;
                            if (title.y) {
                                title.y = 0;
                            }
                            if (title.margin) {
                                title.margin = 0;
                            }
                            delete subtitle.text;
                        }
                        else {
                            title.y = 0;
                            title.margin = 0;
                            delete title.text;
                        }
                    }
                }
                if (isGlobalUpdate) {
                    for (var i = 0; i < self.chartBuilderInstance.panes().length; i++) {
                        let currChart: any = gUtils.findHighchartById(self.view, _.get(self.chartBuilderInstance.panes()[i], 'chartId'));

                        if (action === chartCustomizationAction.updateSubTitle) {
                            //The commented code we need later after solving title issue
                            if (self.chartBuilderInstance.panes()[i].isChildPane) {
                                //  title.text = self.chartBuilderInstance.panes()[i].name();
                                subtitle.margin = 0;
                                subtitle.y = 0;
                                if (title.y) {
                                    title.y = 0;
                                }
                                if (title.margin) {
                                    title.margin = 0;
                                }
                                delete subtitle.text;
                            }
                            currChart.update({ title, subtitle, legend });
                            self.chartBuilderInstance.panes()[i].settings().subTitleFontSettings(updateObjectSettings);
                        }
                        else {
                            if (self.chartBuilderInstance.panes()[i].isChildPane) {
                                title.margin = 0;
                                title.y = 0;
                                delete title.text;
                            }
                            currChart.update({ title, legend });
                            self.chartBuilderInstance.panes()[i].settings().titleFontSettings(updateObjectSettings);
                        }
                        currChart.redraw();
                    }
                }
                else {
                    if (action === chartCustomizationAction.updateSubTitle) {
                        currChart.update({ title, subtitle, legend }, false);
                    }
                    else {
                        currChart.update({ title, legend }, false);
                    }
                }
                if (isRedrawLocal) {
                    currChart.redraw();
                }
            }
        };

        self.generateDummySeries = function () {
            var dummyData = self.generateDummyData(self.chartBuilderInstance.chartDateRange().start, self.chartBuilderInstance.chartDateRange().end);
            return {
                type: "line",
                data: dummyData,
                yAxis: "1000",
                name: "Series 1",
                id: "9999"
            };
        };

        self.getDefaultyAxis = function () {
            return {
                id: "1000",
                min: 0,
                max: 100,
                showLastLabel: true,
                opposite: false,
                title: {
                    text: null
                }
            };
        };

        self.removeHighchartSeries = function (targetSeriesIds: any, paneId: any) {
            var currentPaneId = paneId;
            var currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === currentPaneId; });
            var currChart = gUtils.findHighchartById(self.view, _.get(currentPane, 'chartId'));
            var seriesCol = currChart && currChart.series;
            var yAxisCol = currChart && currChart.yAxis;
            var chartDateRange = self.chartBuilderInstance.chartDateRange;
            if (seriesCol !== undefined) {
                for (var i = seriesCol.length - 1; i > -1; i--) {
                    if (seriesCol[i].name !== 'Series 1') {
                        if (_.contains(targetSeriesIds, seriesCol[i].userOptions.id)) {
                            if (seriesCol[i].userOptions.xAxis === 0 && seriesCol[i].xAxis.series.length === 1) {
                                var sDate = chartDateRange().start.slice(0, 4) + "/" + chartDateRange().start.slice(4, 6) + "/" + chartDateRange().start.slice(6, 8);
                                var eDate = chartDateRange().end.slice(0, 4) + "/" + chartDateRange().end.slice(4, 6) + "/" + chartDateRange().end.slice(6, 8);
                                gUtils.setXAxesExtremes(currChart,
                                    Date.parse(sDate), Date.parse(eDate));
                            }
                            anntUtil.removeAnnotationBySeries(currChart, seriesCol[i].userOptions.id);
                            pinnAnnt.removeSeriesPinnAnnt(seriesCol[i].userOptions.id);
                            seriesCol[i].remove();
                        }
                    }
                }
            }

            var lazyRemove = false;
            if (yAxisCol !== undefined) {
                for (var j = yAxisCol.length - 1; j > -1; j--) {
                    if (yAxisCol[j].series.length === 0) {
                        if (yAxisCol.length === 1) {
                            lazyRemove = true;
                        } else {
                            yAxisCol[j].remove();
                        }
                    }
                }
                yAxisUtil.removeYAxisHack();

                if (yAxisCol.length === 1 && yAxisCol[0].userOptions.id !== "1000") {
                    if (yAxisCol[0].opposite) {
                        yAxisCol[0].update({ opposite: false });
                        if (yAxisCol[0].series.length === 1 && yAxisCol[0].series[0].visible === false) {
                            yAxisCol[0].visible = false;
                        }
                    }
                } else {
                    var cnt = 0;
                    _.each(yAxisCol, function (y: any) {
                        if (y.opposite === false) {
                            cnt = cnt + 1;
                        }
                    });
                    if (cnt === 0) {
                        if (yAxisCol[0] !== undefined && yAxisCol[0].opposite) {
                            yAxisCol[0].update({ opposite: false });
                            if (yAxisCol[0].series.length === 1 && yAxisCol[0].series[0].visible === false) {
                                yAxisCol[0].visible = false;
                            }
                        }
                    }
                }
                if (seriesCol.length === 0) {

                    currChart.addAxis(self.getDefaultyAxis());
                    currChart.addSeries(self.generateDummySeries());
                    if (lazyRemove) {
                        yAxisCol[0].remove();
                    }
                    yAxisUtil.removeYAxisHack();

                    //periodicUtil.updatexAxisLabels();
                    var stDate = chartDateRange().start.slice(0, 4) + "/" + chartDateRange().start.slice(4, 6) + "/" + chartDateRange().start.slice(6, 8);
                    var edDate = chartDateRange().end.slice(0, 4) + "/" + chartDateRange().end.slice(4, 6) + "/" + chartDateRange().end.slice(6, 8);
                    gUtils.setXAxesExtremes(currChart,
                        Date.parse(stDate), Date.parse(edDate));

                    //Reset Plotted Date when no series data available
                    self.onPlottedDatesChanged(chartDateRange().start, chartDateRange().end);
                }
                _.each(currChart.yAxis, function (yAxis: any) {
                    yAxisUtil.updateYAxisExtremes(false, yAxis, self.yAxes(paneId), undefined, undefined, undefined, undefined);
                });

                periodicUtil.updatexAxisLabels(currChart.series, currChart.xAxis[0]);
                self.chartChangedCB();

                if (currChart.yAxis.length > 1) {
                    currChart.yAxis[1].update({ x: -20 });
                }
            }
            if (!self.isLoadChart) {
                self.updateChildpaneWidth(self.view);
            }
            self.isLoadChart = false;
        };

        self.removeHighChart = function (chartIndex: number) { // removing object from window.highchart
            if (chartIndex !== 0 && chartIndex !== -1) {
                //Removing all invalid vals. Replacing the _.compact without replacing the window.Highcharts.charts with a copy of the array
                var charts = window.Highcharts.charts;
                var emptyValI = _.findIndex(charts, (chart: any) => !chart);
                while (emptyValI >= 0) {
                    charts.splice(emptyValI);
                    emptyValI = _.findIndex(charts, (chart: any) => !chart);
                }

                window.Highcharts.charts.splice(chartIndex, 1);
            }

            //Updating the data-highcharts-chart attribute which tracks the 
            //chart index in the window.Highcharts.charts object
            _.forEach(window.Highcharts.charts, (chart: any, index: number) => {
                chart.renderTo.setAttribute('data-highcharts-chart', index);
            });

            //reTriggering the parent series collections to set the date
            var parPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === 1; });
            parPane.seriesCollection(parPane.seriesCollection());
        };

        self.removePane = function (paneId: number) {
            var chartContainer = $('.chart-area');
            chartContainer.find('#paneContainer-' + paneId).each(function (this: any) {
                var that: any = this;
                if (paneId !== 1) {
                    if (that.parentNode.remove) {// For IE purpose
                        that.parentNode.parentNode.remove();
                    } else {
                        that.parentNode.parentNode.removeNode(that);
                    }
                    var currentPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
                    self.chartBuilderInstance.panes.remove(currentPane);
                }
            });
        };
        /**
         * Update Chart Type of the selected series
         * @param seriesId : ID of the Selected Series
         * @param chartType: Selected Type: line; column; area; candlestick
         * @param chartTypeId: ID of the selected chart type based on enum defined in GenericUtil.ChartType
         * @param paneId: Pane ID of the Selected Series
         **/
        self.updateSeriesType = function (seriesId: number, chartType: string, chartTypeId: number, paneId: number) {
            let currPane = _.find(self.chartBuilderInstance.panes(), (pane: any) => pane.id === paneId);
            var currChart = gUtils.findHighchartById(self.view, _.get(currPane, 'chartId'));
            var uiSeries = _.find(currPane.seriesCollection(), function (uis: any) {
                return seriesId === uis.id;
            });

            let originalData: any = [];

            var seriesDetails = _.find(currChart.series, (series: any) => series.userOptions.id === seriesId);

            let isCandlestickOrOhlc = _.contains([gUtils.ChartType.Candlestick, gUtils.ChartType.OHLC], chartTypeId);

            if (seriesDetails) {
                if (seriesDetails.userOptions.id === seriesId) {
                    let metricUnit = _.get(seriesDetails, 'userOptions.data[0].meta.mag', "");
                    if ((metricUnit === "%") && isCandlestickOrOhlc) {
                        zone.root.notify({
                            message: chartTypeId === gUtils.ChartType.Candlestick ? webStrings.chartBuilderCandlestickInvalidStyleMessage() : webStrings.chartBuilderOHLCInvalidStyleMessage,
                            type: "warning",
                            dismiss: true
                        });
                        chartType = 'line';
                        self.chartBuilderInstance.reloadAgGrid(true);
                        return;
                    }
                    if (seriesDetails.userOptions.metric.key === 290930) {
                        _.forEach(currPane.seriesCollection(), function (siri: any) {
                            if (seriesDetails.userOptions.id === siri.id && siri.entity.contentSet !== 6) {
                                if (isCandlestickOrOhlc && siri.orignalData.length === 0) {
                                    siri.orignalData = _.clone(seriesDetails.userOptions.data.slice(0), true);
                                }
                                else if (_.contains(['candlestick', 'ohlc'], seriesDetails.userOptions.type)) {
                                    originalData = _.clone(siri.orignalData, true);
                                }
                            }
                        });
                    }
                    if (!isCandlestickOrOhlc) {
                        let zIndx = chartTypeId === gUtils.ChartType.Column ? 0 : 1;
                        if (originalData.length > 0 && !uiSeries.isPeriodic && !seriesDetails.userOptions.isStudy) {
                            let oData = _.clone(originalData);
                            var volMetricsArray = ["1063", "104", "2454"];
                            var isVolMetrics = volMetricsArray.indexOf(seriesDetails.userOptions.metric.keyItem) > -1;
                            var xAxis = isVolMetrics || (chartTypeId !== gUtils.ChartType.Column) ? 0 : 1;
                            seriesDetails.update({
                                data: oData,
                                type: chartType,
                                zIndex: zIndx,
                                xAxis: xAxis
                            }, true);
                        }
                        else {
                            //add xaxis only when all series are period
                            var isAllPeriodic = (series: any[]) => _.every(series, 'userOptions.isPeriodic');
                            if (isAllPeriodic(currChart.series)) {
                                seriesDetails.update({
                                    type: chartType.toLowerCase(),
                                    zIndex: zIndx,
                                    xAxis: chartTypeId === gUtils.ChartType.Line ? 0 : 1
                                }, true);
                            } else {
                                seriesDetails.update({
                                    type: chartType.toLowerCase(),
                                    zIndex: zIndx
                                }, true);
                            }
                            var axis0 = currChart.xAxis[0];
                            var axis1 = currChart.xAxis[1];
                            gUtils.setXAxesExtremes(currChart, axis0.min, axis0.max, axis1.min, axis1.max);
                        }
                    }
                    else {
                        var periodType = _.find(seriesDetails.userOptions.metric.secondaryKeys, function (sk: any) {
                            return sk.key === "cht_01";
                        });
                        var frequency = _.find(seriesDetails.userOptions.metric.secondaryKeys, function (sk: any) {
                            return sk.key === "cht_02" || sk.value.toLowerCase() === "intraday";
                        });
                        var offset = _.find(seriesDetails.userOptions.metric.secondaryKeys, function (sk: any) {
                            return sk.key === "cht_05";
                        });
                        var currency: any = uiSeries.currency !== null ? uiSeries.currency : self.selectedCurrFromDD();
                        var optEntity = seriesDetails.userOptions.entity;
                        var entityId = optEntity.keyUniversalEntity ||
                            optEntity.companySnlKeyInstn ||
                            gUtils.getEntityIdString(optEntity);
                        gUtils.blockChart(true);

                        let seriesMetricKey = seriesDetails.userOptions.metric.key;
                        if (seriesDetails.userOptions.entity.contentSet !== 6 && seriesDetails.userOptions.metric.key === gUtils.equivalancyTotalReturnMetrics[1].key) {
                            seriesMetricKey = gUtils.equivalancyTotalReturnMetrics[0].key;
                        } else if (seriesDetails.userOptions.entity.contentSet === 6 && seriesDetails.userOptions.metric.key === gUtils.equivalancyTotalReturnMetrics[0].key) {
                            seriesMetricKey = gUtils.equivalancyTotalReturnMetrics[1].key;
                        }

                        chartDataModel.getSeriesData(
                            entityId,
                            seriesMetricKey,
                            self.chartBuilderInstance.chartDateRange,
                            {
                                periodType: periodType ? periodType.value : "FQ",
                                frequency: frequency ? frequency.value : (gUtils.isEstimate(seriesDetails.userOptions.metric, true) ? "1" : "daily"),
                                currency: currency,
                                dataFromCacheOnly: false,
                                isStudy: seriesDetails.isStudy,
                                studyType: seriesDetails.studyType,
                                studyPeriod: seriesDetails.studyPeriod,
                                studyStdDev: seriesDetails.studyStdDev,
                                studySeqId: seriesDetails.studySeqId,
                                indexDate: seriesDetails.isStudy && gUtils.isRelativeCapableSiri(seriesDetails) ? gUtils.getIndexDate(seriesDetails.id) : null,
                                offset: offset ? offset.value : 1,
                                extendedFields: ["319188", "290931", "290932"],
                                isCandlestick: true,
                                id: gUtils.getListGUID(seriesDetails.userOptions.entity),
                                contentSet: seriesDetails.userOptions.entity.contentSet,
                                plottedDateRange: self.chartBuilderInstance.plottedDateRange,
                                isEstimate: gUtils.isEstimate(seriesDetails.userOptions.metric, true),
                                isForward: gUtils.isForward(seriesDetails.userOptions.metric),
                                ratesKeyEntityType: optEntity.ratesKeyEntityType
                            }
                        ).then(function (data: any) {
                            for (let value of data) {
                                value[0] = Date.parse(value[0]);
                            }
                            let ohlsdata = _.map(data, gUtils.transformDataPointArrayToObj);
                            seriesDetails.setData(ohlsdata, false);
                            seriesDetails.update({
                                type: chartType.toLowerCase(),
                                zIndex: 1,
                                xAxis: 0
                            }, true);
                            _.forEach(currPane.seriesCollection(), function (series: any) {
                                if (series.id === seriesId) {
                                    series.chartType = chartTypeId;
                                    series.ohlsData = data;
                                }
                            });
                            gUtils.blockChart(false);
                        }).catch(function () {
                            gUtils.blockChart(false);
                        });
                    }
                    _.forEach(currPane.seriesCollection(), function (series: any) {
                        if (series.id === seriesId) {
                            series.chartType = chartTypeId;
                        }
                    });
                }
            }
        };

        self.moveToPane = function (seriesInfo: any, existingPaneId: any = null) {
            let currentSeries = _.find(self.allPanesSeriesArr(), (s: any) => s.id === seriesInfo.selectedSeriesId);
            let studySeries = _.filter(self.allPanesSeriesArr(), (s: any) => _.contains(currentSeries.studySeriesIds, s.id));
            let childPaneStudySeries = _.filter(studySeries, (s: any) => gUtils.plottedInChildPane(s.studyType));
            let newPaneId = existingPaneId ? existingPaneId : self.getPaneId();
            let parentPaneStudySeries = _.difference(studySeries, childPaneStudySeries);
            let targetedSamePaneSeries = _.union([currentSeries], parentPaneStudySeries);
            let targetedSeries = _.union([currentSeries], studySeries);
            self.removeSeries(targetedSeries, false, false);
            currentSeries.studySeriesIds = [];
            //Updating new pane ids to all series
            _.each(targetedSamePaneSeries, (series: any) => series.paneId = newPaneId);
            let macdPaneId: number;
            _.each(childPaneStudySeries, (series: any) => {
                if (series.studyType === gUtils.StudyType.MACD) {
                    if (series.studySeqId === 0) {
                        series.paneId = self.getPaneId();
                        macdPaneId = series.paneId;
                    }
                    else {
                        series.paneId = macdPaneId;
                    }
                }
                else {
                    series.paneId = self.getPaneId();
                }
            });
            currentSeries.isCallByTimeframe = false;
            currentSeries.studySeriesIds = _.pluck(studySeries, 'id');
            //plotting child pane series after parent series plotted
            q.when(self.addSeries([currentSeries])).then(self.addSeries(parentPaneStudySeries)).then(self.addSeries(childPaneStudySeries));
        };

        self.copyToPane = function (selectedSeriesId: any, existingPaneId: any = null) {
            let currentSeries = _.find(self.allPanesSeriesArr(), function (series: any) { return series.id === selectedSeriesId; });
            let copySeriesCollection: any[] = [];
            let newPaneId = existingPaneId ? existingPaneId : self.getPaneId();
            let parentSeries = _.clone(currentSeries, true);
            parentSeries.id = self.getSeriesId();
            parentSeries.studySeriesIds = [];
            parentSeries.paneId = newPaneId;
            let studySeries = _.filter(self.allPanesSeriesArr(), (s: any) => _.contains(currentSeries.studySeriesIds, s.id));
            let macdPaneId: number;
            _.each(studySeries, (series: any) => {
                let copySeries = _.clone(series, true);
                copySeries.id = self.getSeriesId();
                parentSeries.studySeriesIds.push(copySeries.id);
                if (gUtils.plottedInChildPane(copySeries.studyType)) {
                    if (copySeries.studyType === gUtils.StudyType.MACD) {
                        if (copySeries.studySeqId === 0) {
                            copySeries.paneId = self.getPaneId();
                            macdPaneId = copySeries.paneId;
                        }
                        else {
                            copySeries.paneId = macdPaneId;
                        }
                    }
                    else {
                        copySeries.paneId = self.getPaneId();
                    }
                }
                else {
                    copySeries.paneId = newPaneId;
                }
                copySeriesCollection.push(copySeries);
            });
            //plotting study series after parent series plotted
            q.when(self.addSeries([parentSeries])).then(self.addSeries(copySeriesCollection));
        };

        oc.subscribe(self.chartBuilderInstance.panes, function () {
            let mainPanes = _.filter(self.chartBuilderInstance.panes(), (pane: any) => !pane.isChildPane);
            for (var i = 1; i < mainPanes.length; i++) {
                mainPanes[i].name('Pane ' + (i + 1));
            }
        }, null, "arrayChange");
        //#endregion

        oc.subscribe(self.selectedCurrFromDD, function (oldValue: any) {
            self.previousSelectedCurrency = oldValue;
        }, null, 'beforeChange');

        oc.subscribe(self.selectedCurrFromDD, function (newValue: any) {
            var datesChangedByButton = false;
            var currChart = gUtils.findHighchartById(self.view, _.get(self.firstPane(), 'chartId'));
            if (currChart && gUtils.getSeriesOfAllPanes(self.chartBuilderInstance.panes()).length > 0) {
                if (newValue && newValue !== self.previousSelectedCurrency && !_.isNull(self.previousSelectedCurrency) && !_.isUndefined(self.previousSelectedCurrency)) {
                    self.updateSeriesFromTimeFrame(datesChangedByButton, newValue, true);
                }
            }
        });

        self.updateSeriesName = function (seriesId: any, seriesName: any, paneId: number = 1) {
            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === paneId;
            });
            let currChart = gUtils.findHighchartById(view, _.get(currentPane, 'chartId'));

            if (currChart) {
                _.each(currChart.series, function (s) {
                    if (s.userOptions.id === seriesId) {
                        var currentSeries = _.find(self.allPanesSeriesArr(), function (series: any) { return series.id === seriesId; });
                        currentSeries.name = seriesName;
                        s.userOptions.name = seriesName;
                        s.userOptions.customName = seriesName;
                        s.update({ legendName: seriesName }, true);
                    }
                });
            }
            self.allPanesSeriesArr.notifySubscribers(
                self.allPanesSeriesArr());
        };
        self.updateSeriesColor = function (seriesId: any, color: any, paneId: number = 1) {
            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === paneId;
            });
            let currChart = gUtils.findHighchartById(view, _.get(currentPane, 'chartId'));

            if (currChart) {
                _.each(currChart.series, function (s) {
                    if (s.userOptions.id === seriesId) {
                        var currentSeries = _.find(self.allPanesSeriesArr(), function (series: any) { return series.id === seriesId; });
                        currentSeries.color = color;
                        s.userOptions.color = color;
                        s.userOptions.color = color;
                        s.update({ color: color }, true);
                    }
                });
            }
        };


        // Update line width of the selected line series.
        self.updateLineSeriesWidthOrStyle = function (seriesId: number, lineWidth: number, lineStyle: string, updateWidth: boolean, paneId: number = 1) {

            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === paneId;
            });

            let currChart = gUtils.findHighchartById(view, _.get(currentPane, 'chartId'));

            // Apply lineWidth to the Chart Series
            if (currChart) {
                _.forEach(currentPane.seriesCollection(), function (series: any) {
                    if (series.id === seriesId) {
                        if (updateWidth) {
                            if (lineWidth !== undefined && lineWidth !== null) {
                                series.lineWidth = lineWidth;
                            }
                        } else {
                            series.dashStyle = lineStyle;
                        }
                    }
                });

                // TODO: update linewidth only for line type series in specific if it is supported by higcharts.
                _.each(currChart.series, function (series) {
                    if (series.userOptions.id === seriesId) {
                        if (updateWidth) {
                            if (lineWidth !== undefined && lineWidth !== null) {
                                series.userOptions.lineWidth = lineWidth;
                                series.update({ lineWidth: lineWidth });
                            }
                        } else {
                            series.userOptions.dashStyle = lineStyle;
                            series.update({ dashStyle: lineStyle });
                        }
                    }
                });
            }
        };


        self.updateStudySeriesId = function (seriesId: any, newStudySeriesId: any, paneId: number = 1) {
            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === paneId;
            });
            let currChart = gUtils.findHighchartById(view, _.get(currentPane, 'chartId'));

            if (currChart) {
                _.each(currChart.series, function (s) {
                    if (s.userOptions.id === seriesId) {
                        var currentSeries = _.find(self.allPanesSeriesArr(), function (series: any) { return series.id === seriesId; });
                        currentSeries.id = newStudySeriesId;
                        s.userOptions.id = newStudySeriesId;
                    }
                });
            }
        };
        self.updateStudyType = function (seriesId: any, paneId: number = 1) {
            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === paneId;
            });
            let currChart = gUtils.findHighchartById(view, _.get(currentPane, 'chartId'));

            if (currChart) {
                _.each(currChart.series, function (s) {
                    if (s.userOptions.id === seriesId) {
                        var currentSeries = _.find(self.allPanesSeriesArr(), function (series: any) { return series.id === seriesId; });
                        s.userOptions.studyType = currentSeries.studyType;
                    }
                });
            }
        };
        self.updateStudyPaneId = function (seriesId: any, currentPaneId: any, newPaneId: any) {
            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === currentPaneId;
            });
            let currChart = gUtils.findHighchartById(view, _.get(currentPane, 'chartId'));

            if (currChart) {
                _.each(currChart.series, function (s) {
                    if (s.userOptions.id === seriesId) {
                        var currentSeries = _.find(self.allPanesSeriesArr(), function (series: any) { return series.id === seriesId; });
                        currentSeries.paneId = newPaneId;
                        s.userOptions.paneId = newPaneId;
                    }
                });
            }
        };

        self.changeSeriesName = function (seriesid: any, seriesName: any, paneId: number = 1) {
            // var currChart = gUtils.findHighchartById(view, _.get(self.chartBuilderInstance.panes()[0], 'chartId'));
            let currentPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) {
                return pane.id === paneId;
            });
            let currChart = gUtils.findHighchartById(view, _.get(currentPane, 'chartId'));

            if (currChart) {
                _.each(currChart.series, function (s) {
                    if (s.userOptions.id === seriesid) {
                        var currentSeries = _.find(self.allPanesSeriesArr(), function (series: any) { return series.id === seriesid; });
                        currentSeries.name = seriesName;
                        s.userOptions.customName = seriesName;
                        s.update({ legendName: seriesName }, true);
                        currChart.reflow();
                        self.firstPaneSeriesArr.notifySubscribers(
                            self.firstPaneSeriesArr());
                        self.allPanesSeriesArr.notifySubscribers(
                            self.allPanesSeriesArr());
                        self.refreshChartSummary(true);
                    }
                });
            }
        };

        self.getNextAvailableColor = function (seriesCollectionToCompare: any[], colorArray: boolean = false) {
            //var targetedPane = _.find(self.chartBuilderInstance.panes(), function (pane: any) { return pane.id === paneId; });
            let seriesCollection = _.map(self.chartBuilderInstance.panes(), function (pane: any) { return pane.seriesCollection(); });
            var allSeriesOnPanes = _.flattenDeep(seriesCollection);
            // Get Collection of all existing and newly added series
            // var allSeriesCollection = _.union(targetedPane.seriesCollection(), seriesCollectionToCompare);
            var allSeriesCollection = _.union(allSeriesOnPanes, seriesCollectionToCompare);

            // Get colors along with count of series to which this color has been assigned.
            // Output for example: seroesColorsCount = [{color: 'FAB81A', count: 2}, {color: '5B5E5E', count: 1}]

            var currentColors: string[] = _.get(gUtils.AppliedColorPalette, 'colors', []);
            currentColors.push(...gUtils.MISeriesColors);

            var seriesColorsCount = _.map(currentColors, function (color) {
                var colorCount = _.filter(allSeriesCollection, function (series: any) { return series.color.toLowerCase() === color.toLowerCase(); }).length;
                return {
                    color: color,
                    count: colorCount
                };
            });
            if (colorArray) {
                return _.sortBy(seriesColorsCount, 'count');
            } else {
                // Sort by series counts assigned to each color and pick and return first color
                return _.first(_.sortBy(seriesColorsCount, 'count')).color;
            }
        };

        self.loadChartData = function (savedChartMetaData: any) {
            var panes = JSON.parse(savedChartMetaData.Panes);

            _.forEach(panes, function (pane: any) {
                _.forEach(pane.seriesCollection, function (series: any) {

                    var annotations = series.annotations;

                    var isNew = _.some(annotations, (ann: any) => {
                        var annStr = "" + ann;
                        return _.startsWith(annStr, 'type') || _.startsWith(annStr, 'cat');
                    });

                    series.annotations = _.map(annotations, (anno: CBModels.KeyDevId) => {
                        var typeId = anno;
                        return isNew ? typeId :
                            typeId === 160 ? "type:custom" :
                                "type:" + anntUtil.retrieveNodeIdFromTypeId(typeId, self.keyDevTypes());
                    });

                });

            });

            let chartBuilderData = {
                entities: JSON.parse(savedChartMetaData.Entities),
                metrics: JSON.parse(savedChartMetaData.Metrics),
                panes: panes,
                chartDateRange: JSON.parse(savedChartMetaData.Timeframe)

            };

            self.selectedSavedChart = { Name: savedChartMetaData.Name, Key: savedChartMetaData.Key };
            if (!self.isStockChart()) {
                shellViewModel.subHeader.pageTitleContent.viewModel().title.subtitle(self.selectedSavedChart.Name);
            }

            self.plotSavedChart(chartBuilderData);


        };

        self.saveModificationHandler = function () {
            if (self.isReportBuilder) {
                let chartData = self.getChartBuilderData();
                if (chartData.entities.length > 0 && chartData.metrics.length > 0) {
                    ViewUtilities.saveModifications(self.getChartBuilderData());
                }
            }
        };
        self.storeJWT = function () {
            var jwtToken = $("#jwtToken").val();
            document.cookie = "SP_SSO_JWT_COOKIE=" + jwtToken;
            document.cookie = "CIQProvisioned=" + "";
            securityClient.ciqAuthenticate();
            $("#dialog").attr("style", "display:none");
        };

        logOfficeMessages("binding end");
    }

    public attached(view: any) {
        var viewContext = new ViewUtilities(view, self),
            eventContext = viewContext.event;

        if (shellViewModel.subHeader) {
            shellViewModel.subHeader.visible(true);
        }

        if (self.tools.titleExportSchema && self.tools.title) {
            q.when(self.tools.titleExportSchema).then(function (titleExportSchema: string) {
                self.titleExportSchema = titleExportSchema;
            });

            q.when(self.tools.title).then(function (title: string) {
                self.title = title;
            });
        }

        self.innerWidth($(view).innerWidth());
        self.resizeSidebar = _.debounce(gUtils.resizeSidebarPanel, 300);
        self._resizeChartWindow = function () {
            self.innerWidth($(view).innerWidth());

            var hasStyle = false;

            // Check for IE Browser
            if (navigator.userAgent.toLowerCase().match(/msie/) || navigator.userAgent.toLowerCase().indexOf('trident/') > 0) {
                hasStyle = $($('.collapsible_data')[0])[0].hasAttribute('style');
            }
            else {
                hasStyle = $($('.collapsible_data')[0]).attr('style') !== "";
            }

            var chartWidth = hasStyle ? (self.isReportBuilder ? 95 : (self.isStockChartModeEnabled ? 96 : 97)) :
                (self.isReportBuilder ? 58 : (self.isStockChartModeEnabled ? 67 : 72));

            //if (!$($('.collapsible_data')[0])[0].hasAttribute('style'))
            //Here width needs to be calculated based on innerWidth of the window. Thats why window.innerWidth is required here.
            var adjustedWidth = (self.innerWidth() * (chartWidth / 100)) - (self.innerWidth() < 768 ? 0 : 25);
            $("#pane-sidebar-block").css('width', adjustedWidth - 25 + 'px');

            _.each(self.chartBuilderInstance.panes(), (pane: any) => {
                var currChart = gUtils.findHighchartById(self.view, pane.chartId);
                // let chartHeight = gUtils.getChartHeight(undefined, pane.isChildPane);
                if (currChart) {
                    self.updateChildpaneWidth(self.view);
                    currChart.reflow();

                    // currChart.setSize(adjustedWidth, currChart.legend.legendHeight + chartHeight, true);
                    // self.updateChildpaneWidth(self.view);
                }
            });

            self.resizeSidebar();
        };

        self._resizeHandler = _.debounce(_.bind(self._resizeChartWindow, self), 300);
        eventContext.appOn(eventConstants.resize.client, self._resizeHandler);

        if (self.isStockChart()) {
            eventContext.appOn(eventConstants.menu.update, self._resizeHandler);
        }

        if (!_.some(gUtils.userDefinedColorPalettes)) {
            // Retrieve user defined color palettes
            chartDataModel.getColorPalette().then((userPalettes: any) => {
                var palettes = [];

                if (!userPalettes) {
                    return;
                }

                if (userPalettes.default) {
                    palettes.push(_.extend(userPalettes.default, { isDefault: true }));
                    gUtils.MISeriesColors = userPalettes.default.colors;
                    self.selectedColorPaletteId(userPalettes.default.id);
                }

                palettes.push(...userPalettes.custom);

                // Assign Palette to common object to avoid duplicate service calls
                gUtils.userDefinedColorPalettes = _.sortBy(palettes, (palette: any) => palette.id);

            });

        }
        // self.updateChildpaneWidth(self.view);
    }

    public dropdownCloseCB() {
        var currentEntities = self.chartBuilderInstance.entities();
        var currentEntitiesLen = _.get(currentEntities, 'length', 0);
        var prevEntitiesLen = _.get(self.previousEntities(), 'length', 0);
        if (!self.disableAutoOpen && currentEntitiesLen === 1 && prevEntitiesLen === 0) {
            self.selectFieldSearchControl(self.view);
        }
        self.previousEntities(currentEntities.slice());
    }

    private selectFieldSearchControl(view: any) {
        if (!self.isPlattsEnabled && $('.snl-views-shared-searchControl-offcanvas:visible').length === 0) {
            var fieldInput = $(view).find('.snl-widgets-input-autocomplete-filter').first();
            $(view).on('mouseup.selectFieldSearch', function () {
                $(view).off('mouseup.selectFieldSearch');
                return false;
            });
            fieldInput.click();
            fieldInput.focus();
        }
    }
    public updateChildpaneWidth(view: any) {
        let firstPaneChart = gUtils.findHighchartById(view, _.get(self.chartBuilderInstance.panes()[0], 'chartId'));
        var siriLen = _.filter(firstPaneChart.series, function (siri: any) { return siri.visible; });
        var lineSpace = siriLen.length === 0 ? -15 : 15;
        _.each(self.chartBuilderInstance.panes(), function (pane: any) {
            if (pane.isChildPane) {
                let currPane = gUtils.findHighchartById(self.view, _.get(pane, 'chartId'));

                if (currPane) {
                    currPane.setSize(firstPaneChart.plotWidth + currPane.plotBox.x + lineSpace, gUtils.getChartHeight(undefined, pane.isChildPane));
                }
            }
        });
    }

    public compositionComplete(view: any) {
        logOfficeMessages("Composition start");
        var that = this;

        $('.select2-selection__rendered').keydown(function (e: any): any {
            var code = e.keyCode || e.which;
            if (Number(code) === 9) {
                if (self.chartBuilderInstance.entities().length > 0) {
                    that.selectFieldSearchControl(view);
                    e.bubbles = false;
                    return false;
                }

            }
        });

        // $('.snl-views-subheader-pagetitle-text-main').remove();
        self.compComplete(true);
        //#region Office Edit Chart
        function officeEditMeth() {
            if (common.isOffice && !self.isOfficeInsertMode()) {
                var officeInstance = self.officeExportChart;
                if (officeInstance && officeInstance.officeArgument()) {
                    var chartBuilderData = officeInstance.officeArgument().chartBuilderData;
                    var mode = ResetChartBuilder.ResetType.OfficeEdit;
                    if (ko.utils.unwrapObservable(self.isOfficeRefreshMode)) {
                        mode = ResetChartBuilder.ResetType.OfficeRefresh;
                    }
                    ResetChartBuilder.resetChartBuilder(chartBuilderData, mode, self);
                }
            }
        }

        officeEditMeth();
        /*
         * Trigger Edit chart work flow once chart data is retrieved from state store
         */
        self.viewContext.observable.subscribe(self.officeExportChart.officeArgument, function () {
            if (self.compComplete()) {
                officeEditMeth();
            }
        });

        //#endregion
        if (self.isPlattsEnabled) {
            var priceMetricObject = { key: 320318 };
            self.preservedMetrics([priceMetricObject]);
        }
        //#region Stock Chart Redirection
        self.reportBuilderSavedData = undefined;
        if (self.isStockChartModeEnabled && (common.isReportBuilderPreview() || common.isReportBuilder())) {
            ViewUtilities.getStorageItemForCurrentRBPreviewItem().done(function (data: any) {
                if (data != null) {
                    var jsonData = JSON.parse(JSON.stringify(data));// JSON.parse(data.Panes);
                    var panes = jsonData.panes;// JSON.parse(data.Panes);

                    _.forEach(panes, function (pane: any) {
                        _.forEach(pane.seriesCollection, function (series: any) {

                            var annotations = series.annotations;

                            var isNew = _.some(annotations, (ann: any) => {
                                var annStr = "" + ann;
                                return _.startsWith(annStr, 'type') || _.startsWith(annStr, 'cat');
                            });

                            series.annotations = _.map(annotations, (anno: CBModels.KeyDevId) => {
                                var typeId = anno;
                                return isNew ? typeId :
                                    typeId === 160 ? "type:custom" :
                                        "type:" + anntUtil.retrieveNodeIdFromTypeId(typeId, self.keyDevTypes());
                            });

                        });

                    });

                    let chartBuilderData = {
                        entities: jsonData.entities,
                        metrics: jsonData.metrics,
                        panes: panes,
                        chartDateRange: jsonData.chartDateRange
                    };
                    self.reportBuilderSavedData = chartBuilderData;
                    self.plotSavedChart(chartBuilderData);
                }
                else {
                    self.tools.companyDTO.then((companyDTO: any) => {
                        //Identify whether entity is fund or company
                        var prefix: string = 'company';
                        if (companyDTO.isFundProfile) {
                            prefix = 'funds';
                        }

                        var entityObject = { id: stringUtilities.format('{0}_{1}', prefix, self.stockChartEntityId) };            // Construct DTO to maintain consistency
                        var dayCloseMetricObject = { key: 290930 };
                        var volumeMetricObject = { key: 290942 };
                        var chartingModel = {};
                        let entities = [];

                        var promiseS = stockChartUtil.getIndexes(companyDTO, self.stockChartEntityId);
                        promiseS.then(function (data: any) {
                            if (!_.isNull(data)) {
                                entities = [entityObject, { id: "index_" + data[0] }];
                            } else {
                                entities = [entityObject];
                            }
                            chartingModel = {
                                entities: entities,
                                metrics: [dayCloseMetricObject, volumeMetricObject]
                            };
                            ResetChartBuilder.resetChartBuilder(chartingModel, ResetChartBuilder.ResetType.StockChart, self);
                        });
                    });
                }
            });
        }
        //#region Stock Chart Redirection
        else if (self.isStockChartModeEnabled) {
            self.tools.companyDTO.then((companyDTO: any) => {
                // Identify whether entity is fund or company
                var prefix: string = 'company';
                if (companyDTO.isFundProfile) {
                    prefix = 'funds';
                }

                var entityObject = { id: stringUtilities.format('{0}_{1}', prefix, self.stockChartEntityId) };            // Construct DTO to maintain consistency
                var dayCloseMetricObject = { key: 290930 };
                var volumeMetricObject = { key: 290942 };
                var chartingModel = {};
                let entities = [];

                var promiseS = stockChartUtil.getIndexes(companyDTO, self.stockChartEntityId);
                promiseS.then(function (data: any) {
                    if (!_.isNull(data)) {
                        entities = [entityObject, { id: "index_" + data[0] }];
                    } else {
                        entities = [entityObject];
                    }
                    chartingModel = {
                        entities: entities,
                        metrics: [dayCloseMetricObject, volumeMetricObject]
                    };
                    ResetChartBuilder.resetChartBuilder(chartingModel, ResetChartBuilder.ResetType.StockChart, self);
                });
            });
        }
        var qsDict = uriUtilities.getCurrentParams();
        if (qsDict && qsDict.chartid) {

            let sharing: any = common.config.uris.security.sharing;
            let checkSharingUrl = sharing.createSharedItemAccess.replace('CreateSharedItemAccess', 'GetSharedItemAccess');
            let sharingItemId = qsDict.chartid.split('_')[1];

            ajaxUtilities.ajaxRequest({
                url: checkSharingUrl,
                type: "POST",
                dataType: "json",
                data: JSON.stringify({ "OID": sharingItemId, "keyOnlineUser": securityClient.userProfile().KeyOnlineUser }),
                cache: true
            }).then(function (data) {
                if (data === "No Data Found") {
                    let getSharedItemWithMeUrl = sharing.GetSharedItemWithMe + "?oid=" + sharingItemId;

                    ajaxUtilities.ajaxRequest({
                        url: getSharedItemWithMeUrl,
                        type: "GET"
                    }).then(function (data) {

                        if (data === "No Data Found") {
                            zone.root.notify({
                                message: "Based on your current settings, you do not have access to this shared chart. Please check permissions and try again.",
                                type: "error",
                                dismiss: true
                            });
                        }
                        else {
                            self.keyOnlineSharedItem = data.KeyOnlineSharedItem;
                            self.sharedItemAccessLevel = data.AccessLevel;
                            self.onlineSharedItemShareable = data.OnlineSharedItemShareable;
                            if (self.sharedItemAccessLevel === "View") {
                                self.saveChartButtonText("Save As");
                            }
                            self.loadsavedChart(qsDict.chartid);
                        }

                    });

                }
                else {
                    self.loadsavedChart(qsDict.chartid);

                }

            });

        }



        //#endregion
        logOfficeMessages("Composition end");
    }

    public detached() {

        if (intraday.realTimeModel) {
            intraday.realTimeModel.dal.close();
            intraday.realTimeModel = null;
        }
    }
}

export = ChartBuilderViewModel;